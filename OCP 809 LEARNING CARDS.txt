STAMPEN























































---------------  [[[CHAPTER 1 ]]] --------------------------p.1





ACCESS MODIFIERS - WHICH ONES AND WHEN TO ACCESS


public: all can access
protected: package private and children
package-private/default: only same package
private: only same class


ACCESS MODIFIERS - WHAT DOES SAME PACKAGE REALLY MEAN 


default and protected are same package
same package is literal: cat and cat.species are NOT same package


WHAT DOES THE REFERENCE VARIABLE USED HAVE TO DO WITH ACCESS


package cat;  
public class BigCat {     
	public String name = "cat";     
 	protected boolean hasFur = true;     
 	boolean hasPaws = true;     
 	private int id; 
 	BigCat cat = new BigCat();
} 
package cat.species;  
public class Lynx extends BigCat { BigCat cat = new BigCat(); } 

package cat;  
public class CatAdmirer { BigCat cat = new BigCat(); } 

package mouse;  
public class Mouse { BigCat cat = new BigCat(); }


which variables can these 4 classes access through the cat reference?

BigCat: name hasFur hasPaws id
Lynx: name
CatAdmirer: name hasFur hasPaws
Mouse: name


WHY CANT LYNX ACCESS HASFUR THROUGH THE CAT REFERENCE


Code is being accessed through the variable which is a BigCat
If hasFur had been used through inheritance it would be fine:
Lynx cat = new Lynx();
cat.hasFur; is fine since it now benefits from protected.


WHAT IS THE RULE FOR PROTECTED THEN


To benefit from protected access you need to access the variables 
through inheritance and not through other variables.


JAVA IS CASE SENSITIVE AND OVERRIDE/OVERLOAD EXAMPLE


1:    public class Bobcat {
2:       public void findDen() { }
3:    }
1:    public class BobcatKitten extends Bobcat {
2:       public void findDen() { }
3:       public void findDen(boolean b) { }
4:       public  int findden() throws Exception { return 0; }
5:    }


OVERLOAD CLOSEST MATCH RULES


same method name but different parameter list, return doesnt matter
1 Exact match by type
2 Matching a superclass type
3 Converting to larger primitive type
4 Converting to an autoboxed type
5 Varargs


OVERRIDING RULES


1 method name and parameter list has to be exactly the same
2 access modifier has to be same or broader / more accessible
3 return type must be same or a subclass = covariant
4 if checked exceptions are thrown, same or subclasses are allowed
5 method can not be static because that is hidden

access up/broader/less restrictive
returntype+exception down/narrower/more restrictive


FILL IN THE BLANK
abstract class Cat {   
	_____________________
}
class Lion extends Cat { void clean() {} }


1 leave it empty!          //abstract is not required to have methods
2 abstract void clean();   //abstract method needed to be implemented
3          void clean() {} //normal method that can be overridden


STATIC AND FINAL EXCERCISE - APPLY SAFELY WHERE


1:    abstract class Cat {
2:       String name = "The Cat";
3:       void clean() { }
4:    }
5:    class Lion extends Cat {
6:       void clean() { }
7:   }


2: can be static + final
3: can not be final and can only be static if 6: is also static
6: can be final but only static if 3: is also static
so 3: and 6: can not independently be static


INSTANCEOF - DEFINITION


a instanceof B -> this is true if 'a' points to a reference that is:
a) an instance of B
b) a subclass of B (directly or indirectly)
c) implements the B interface


INSTANCEOF - EXAMPLE


class HeavyAnimal { }
class Hippo extends HeavyAnimal { }
class Elephant extends HeavyAnimal { }
12:   HeavyAnimal hippo = new Hippo();
13:   boolean b1 = hippo instanceof Hippo;
14:   boolean b2 = hippo instanceof HeavyAnimal;
15:   boolean b3 = hippo instanceof Elephant;


13 = true, 14 = true, 15 = false
hippo, a HeavyAnimal, can be a HeavyAnimal, Elephant or Hippo
It is in fact here a Hippo
So Hippo and superclass are correct
It could have been an Elephant, but java knows runtime its a Hippo


REF INSTANCEOF OBJECT - WILL THIS ALWAYS RETURN TRUE


recall the definition of instanceof ...

No, all classes are Objects, but if the reference is literal 'null'
or the reference is pointing to a null object it is false.


NULLREF INSTANCEOF OBJECT


false


INSTANCEOF - WHEN WILL YOU GET A COMPILER ERROR


If the objectRef has no relation to the Class.
[String] s instanceof Date => It will not even compile,
because the compiler knows that 's' (which is declared as of class 
String) can NEVER refer to an object of class java.util.Date. So, it 
will not accept this code.


DOES THIS CHANGE WITH: INTERFACEREF INSTANCEOF CLASS


yes, java does not check interfaces compile time, because runtime
a subclass could implement the interface
you dont know until runtime

interfaceRef instanceof Class
this is true or false but NOT a compile error

because you could subclass Class and then implement the interface
and then it would be true! so no compiler error


OBJECTREF INSTANCEOF NULL = 


compile error 'not a statement'

null instanceof Object
nullRef instanceof Object
ref instanceof null 
refA instanceof UnrelatedClass
interfaceRef instanceof UnrelatedClass
x.equals(null)
x.equals(WrongType)

last one both false, not compiler error!


VIRTUAL METHOD INVOCATION - WHAT DOES THIS MEAN


it means simply that for methods, java will look for overridden methods 
in subclasses, only for ocp 8 it is actually called VMI


WHAT MEMBERS WILL BE USED WHEN SUBCLASSING COMPILE AND RUNTIME


compile time it all has to exist
runtime variables: always the class type that calls
runtime methods: overridden methods from the subclass
class Animal {}
class Lion extends Animal {}
Animal animal = new Lion();
overridden methods from Lion but variables from Animal


WHAT DOES == DO AGAIN


1 compare primitives 
2 check if two references point to the same object


IF YOU SEE @OVERRIDE ON THE EXAM: CHECK FOR 1 OF 3 THINGS 


1 implement method from interface
2 override method of superclass
3 override method of Object (hashcode, tostring, equals) !!!! see next


WHAT IS THE SIGNATURE OF EQUALS AND WHY IS IT IMPORTANT FOR OVERRIDING


public boolean equals(Object obj)
make sure it takes an Object and not something else = overloading
exam trick to see if you know how to override equals()


EXAM TRICK


@Override
public boolean equals(Animal a) { //custom implementation }

= compile error because you are not overriding equals but overloading
remove the annotation to compile


WHAT DOES EQUALS() DO AGAIN


1 if not overridden and using the Object.equals(), same as ==
2 if overridden, uses implementation for example String checks content


WHEN IS THIS. NOT NECESSARY


when the variable names are not the same, you can omit this.


WHAT DOES X.EQUALS(NULL) DO


return false and NOT throw a NullPointerException


WHEN IS EQUALS() REQUIRED TO RETURN FALSE


when you pass in null or the wrong type
x.equals(null) or x.equals(wrongType)  => return false!


WHAT IS THE SIGNATURE OF HASHCODE()


public int hashCode() {}


WHAT ARE THE RULES FOR LEGAL HASHCODE


1 hashCode must not change in the same program, always return same umber
2 if equals() is true, hashCode() must be true (use subset of equals)
3 if equals() is false, hashCode can still be true
if equals() uses idNumber, which are legal hashCode() methods:
16: public int hashCode() { return idNumber; }
17: public int hashCode() { return 6; }
18: public long hashcode() { return idNumber; }
19: public int hashCode() { return idNumber * 7 + age; }

16 and 17 are fine
18 is lowercase c so its not an override, its an overload
	it would not compile anyway if it was an override
19 is wrong because it uses more variables than equals()


RULE OF THUMB TO MAKE A HASHCODE()


Just pick the key fields that identify your object (and don’t change 
during the program) and combine them. Only use equals() fields or subset


FINAL VARIABLES - WHEN IS A VALUE NECESSARY


1 local = assigned a value before USE (beware if statements)
2 instance/static = assigned a value at latest in constructor or 
static initializer


WHAT DOES A FINAL REFERENCE MEAN


reference = cant change but object can change


ENUMS - VALUES


1 values are static final values
2 abstract method implemented for all values or else compile error
3 listed first
4 only need ; if you list more stuff


ENUMS - HIERARCHY


1 private constructors (not part of class hierarchy)
2 cannot be extended because they internally extend Enum class and 
there is no multiple inheritence in java


WHAT IS THE DEAL WITH ENUM INITIALIZATION


initialized once!!
public enum OnlyOne {
 	ONCE(true);   // only ENUM in this enum
 	private OnlyOne(boolean b) {
 		System. out .println("constructing");
 	}
 	public static void main(String[] args) {
 		OnlyOne firstCall  = OnlyOne.ONCE ; // prints constructing
 		OnlyOne secondCall = OnlyOne.ONCE ; // doesn't print anything
} }


ENUMS - STANDARD METHODS OF ENUM


1 values() - lists values
2 ordinal() = select value but is not an int!!!
3 name()
4 valueOf(String) //match exactly
WINTER 0 < not an int, numbered from 0
SPRING 1
SUMMER 2
FALL 3


CAN YOU COMPARE INT WITH AN ENUM VALUE


No, because enums are types and not primitive int
if ( Season.SUMMER == 2) {}

does not compile


HOW CAN YOU USE == WITH ENUMS


checking enum refs against an enum 
Season s = Season.SUMMER;
System.out.println(s == Season.SUMMER); // true


WHY IS AN ENUM BETTER THAN CONSTANTS


You have type-safe checking at compile time vs constants runtime


IS AN ENUM CASE SPECIFIC AND WHEN WILL YOU KNOW - COMPILE OR RUNTIME


Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // Throws an exception at runtime


HOW TO CALL AN ENUM METHOD


enumName.enumValue.enumMethod()
1: public enum Season {
2: 	WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3: 	private String expectedVisitors;
4: 	private Season(String expectedVisitors) {
5: 		this.expectedVisitors = expectedVisitors;
6: 	}
7: 	public void printExpectedVisitors() {
8: 		System.out.println(expectedVisitors);
9: 	}
Season.SUMMER.printExpectedVisitors(); //High
you dont call the constructor, it is run once to load
constructor is also private remember


HOW TO USE ENUM IN A SWITCH


with just the enum value name since java knows it has to be enum
Season summer = Season.SUMMER;
switch (summer) {
	case WINTER:
 		System.out.println("Get out the sled!");
 		break;
}


WHEN CAN YOU SEE A PRIVATE INTERFACE


as a nested inner interface


NESTED CLASSES DIAGRAM + REASONS


Nested classes
|__Static nested class
|__Non-static nested class (inner classes)
   |__member inner class
   |__local inner class
   |__local anonymous class

You create a nested class instead of a new top-level class because:
1 it has special access to members of the parent class
2 organization if the class is only used in this context
3 convenience meaning you dont get an extra file to work with


STATIC NESTED CLASSES


1 A static nested class is behaviorally like a top level class!
3 can only reference non-static outer stuff through explicit reference
4 does not need outer instance to exist its a static member of outer


HOW DO YOU IMPORT A STATIC NESTED CLASS


2 can import the class with or without static


KNOW HOW TO USE IMPORTS AND STATIC IMPORTS


HOW CAN CLASSES BE IMPORTED 


Classes can be imported by class name or wildcard. 
Wildcards do not look at subdirectories. 


WHAT HAPPENS IN A CONFLICT OF IMPORTS


In the event of a conflict, class name imports take precedence. 


HOW TO IMPORT STATIC STUFF


Static imports import static members. They are written as import 
static, not static import. 
Make sure that they are importing static methods or variables rather 
than class names!!!


NON-STATIC INNER CLASSES


1 access EVERYTHING from the outer class
2 need outer instance to exist


HOW TO CREATE A NESTED INNER CLASS


with constructor 
outer.new Inner();
new Outer().new Inner();


LOCAL INNER CLASSES


1 only exists on method call until method out of scope
2 declare in: method, constructor or initializer
3 access everything from outer class
4 only access local variables if they are final or effectively final


ANONYMOUS INNER LOCAL CLASS


1 local class with no name
2 declare + instantiated in one statement: new Type() {};
3 extends or implement one type


HOW TO DECLARE AN ANONYMOUS INNER CLASS

void methodName() {
	new Type() { //lots of stuff here }; //anon class out of scope here
	Inner nestedClass {
		// more stuff here
	}
} //local class out of scope here
dont forget the semicolon at the end of the anon declaration!!!!!!!!!


NESTED CLASS RECAP - ACCESS MODIFIERS


inner class : all
static nested class : all
local class : none
anonymous class : none


NESTED CLASS RECAP - CAN BE STATIC


inner, static : yes
local, anonymous, top level : no


NESTED CLASS RECAP - ABSTRACT OR FINAL


inner, static, local class : yes
anonymous class: no


NESTED CLASS RECAP - MEMBERS - INSTANCE METHODS


inner, static, local, anonymous : yes


NESTED CLASS RECAP - MEMBERS - INSTANCE VARIABLES


inner, static, local, anonymous : yes


NESTED CLASS RECAP - MEMBERS - STATIC METHODS


static : yes
inner, local, anonymous : no


NESTED CLASS RECAP - MEMBERS - STATIC VARIABLES


static : yes
inner, local, anonymous : yes if the variable is made final


NESTED CLASS RECAP - ACCESS RULES - EXTEND OR IMPLEMENT ANY CLASS


inner, static, local : yes
anonymous : exactly one superclass or one interface


NESTED CLASS RECAP - ACCESS RULES - OUTER CLASS INSTANCE VARS + METHODS


inner, local, anonymous : yes
static : no (only indirectly through outer instance)


NESTED CLASS RECAP - ACCESS RULES - OUTER CLASS STATIC VARS + METHODS


inner, local, anonymous, static : yes


NESTED CLASS RECAP - ACCESS RULES - LOCAL VARIABLES OF METHOD


inner, static : N/A
local, anonymous : yes if final or effectively final









----------------     [[[CHAPTER 2 ]]]  ----------------------p.47









WHAT KEYWORDS ARE NOT ALLOWED FOR DEFAULT METHODS


static
abstract
final


WHAT HAPPENS IF A CLASS IMPLEMENTS 2 INTERFACES WITH THE SAME DEFAULT


implementing class must provide its own implementation or else
no compile


HOW DO YOU ACCESS INTERFACE DEFAULT IF YOU OVERRIDE IT


InterfaceName.super.methodName();


CAN AN INTERFACE BE MARKED FINAL


no


WHY NOT FINAL


interfaces are assumed to be 

abstract!


ALL INTERFACE METHODS ARE 


public


ALL INTERFACE VARIABLES ARE 


public static final


WHAT KEYWORD DOES A NON-STATIC NON-DEFAULT METHOD GET IN INTERFACE


abstract


HOW DO INTERFACES ALLOW FOR LIMITED MULTIPLE INHERITANCE


you can implements any number of interfaces and extend classes that 
also implement interfaces





FUNCTIONAL INTERFACES


1 only 1 abstract method
2 Object methods do not count
3 can not declare methods that conflict with Object:
	> String toString()
	> boolean equals(Object o)
	> int hashCode()


WHAT DOES THE @FUNCTIONALINTERFACE ANNOTATION DO


make sure your interface has a SAM else compiler error


FI RELATION WITH LAMBDA


1 lambda implements FI
2 lambda left side contains variables == FI parameters type+number
3 lambda right side contains return type == FI return type


CAN LAMBDAS USE LOCAL VARIABLES


yes, lambda can use local variables if final or effectively final


OTHER NAME FOR LAMBDA


anonymous method passed to a method relying on deferred execution


DEFERRED EXECUTION


specify code now but run later


WHICH TYPES USE EFFECTIVELY FINAL


1 local classes
2 lambdas


WHAT HAPPENS IF YOU USE A LAMBDA WITH A NON-FI


compiler error, what must the lambda do?


USING A FI WITH A LAMBDA


lambda used as parameter
lambda context has to match the FI context
remember: if not FI, compiler error!
lambda parameters + return must match FI parameters + return


CAN LAMBDA RE-DECLARE LOCAL VARIABLE


no, can not re-declare local var or re-declare lambda parameter


EXAMPLE FI AND LAMBDAS

public class FindMatchingAnimals {   
	private static void print(Animal animal, CheckTrait trait) {      
		if(trait.test(animal))         
		System.out.println(animal);   
	}   
	public static void main(String[] args) {      
		print(new Animal("fish", false, true), a -> a.canHop());      
		print(new Animal("kangaroo", true, false), a -> a.canHop());   
}}

print() expects 2 parameters: Animal and CheckTrait references
you supply print() with a new Animal() and a lambda
Java will take the lambda and treat it like a FI because it expects a 
CheckTrait interface reference
Java maps the lambda to the FI's SAM, thats why there can be only one
Thats why the parameters and return value of the lambda and the SAM
have to match exactly


ARE THESE VALID LAMBDAS


(int y, z) -> {int x=1; return y+10; }
a -> {return a.startsWith("test");}
(String a, String b) -> a.startsWith("test")
(a, Animal b, c) -> a.getName()
(String s, int z) -> { return s.length()+z; }
(a, b) -> { int a = 0; return 5;}


WHAT IS POLYMORPHISM


Polymorphism also allows one object to take on many different forms.


WHAT REFERENCE TYPE CAN ACCESS A JAVA OBJECT


1 ref of the same type
2 ref that is a superclass of the object
3 ref that defines an interface that the object implements

interface Animal {}
class Cat {}
public class Tiger extends Cat implements Animal {}
Tiger tiger = new Tiger();
Cat cat = new Tiger();
Animal animal = new Tiger();


WHEN IS A CAST REQUIRED FOR THE ABOVE REFERENCES


you dont need a cast if you go up the hierarchy
because the object is always itself, a superclass or interface impl.

Tiger tiger2 = cat;

this will not compile because you go down the hierarchy
cat is a Cat type you want to put in a Tiger ref. 
So, is a Cat always a Tiger? No, a Tiger can have more members than a 
Cat has. So Java does not allow it.


HOW TO FIX THIS


with a cast!
Tiger tiger2 = (Tiger)cat;
Now you promise Java that at runtime, cat is actually a Tiger and since
a Tiger is always a Tiger the code compiles fine.
If at runtime cat is not a Tiger? ClassCastException.


MIXING REF AND OBJECT TYPES: WHEN COMPILER ERROR


when you call a variable or method that does not exist on the ref
Cat cat = new Tiger();
Cat determines what you can access from the Tiger



WHAT IS THE DISTINCTION BETWEEN OBJECT VS REFS REGARDING PROPERTIES 


type of object in memory determines which properties exist
type of ref to object determines which properties can be accessed


HOW CAN YOU ACCESS ALL PROPERTIES ANYWAY


with a cast


WHEN IS CASTING REQUIRED


not when you go upwards or leftwards
Superclass <= Subclass
target     <= source

it is required when you go right or down
Subclass = (Subclass)Superclass
target   =           source


EXAMPLE OF NEEDED CAST


Capybara extends Rodent
Rodent rodent = new Rodent();
Capybara capybara = rodent;
cast needed?
rodent is of the Rodent type, so you ask: is a Rodent always a Capybara?
no! so cast required
Capybara capybara = (Capybara)rodent;


WILL ABOVE EXAMPLE BE OK


no, ClassCastException at runtime since rodent is not a Capybara object


WHAT HAPPENS IF YOU CAST UNRELATED CLASSES


compiler error
java knows if something is unrelated: exam tricks!!


DESIGN PRINCIPLES - WHAT IS IT


idea or best practice to better the software process


DESIGN PRINCIPLES LEAD TO 


1 more logical code
2 easier to understand code
3 reusable classes
4 easier to maintain classes


WHAT IS DATA MODEL


representation of objects and properties in relation to real world


FUNDAMENTAL PRINCIPLE OF OBJECT-ORIENTED DESIGN IS 


encapsulation: private fields and public getters and setters
users dont operate on data, methods operate on data


WHAT IS AN INVARIANT


a property or truth that is maintained even if the data is modified

examples:

1 the Animal class can not have non-null/empty species field
2 the Animal class will have an age >= 0

these 2 rules must be maintained even if data is modified


HOW CAN YOU GARUANTEE INVARIANTS


with encapsulation so the fields are modified in ways you accept
use a constructor with arguments that get validated on new ()

public Animal(String species) {
	if (species==null || species.trim().length() <= 0) {
		throw new IllegalArgumentException("Species must be supplied.");
	}
}


WHAT IS A JAVABEAN


a standard convention for classes that store data
a design principle for encapsulating data in an object
it is a class for storing data that follows certain rules/conventions


WHAT ARE THE RULES FOR JAVABEANS


fields are 

private

getters and setters are 

public

getter non-boolean starts with 

get

getter boolean starts with 

get or is

getter Boolean starts with 

get

setter starts with 

set

getter/setter start with 

prefix get/is/set and uses fieldname + capital

private boolean Bird;
public isBird() {};
public setBird() {};
public getBird() {};
public setNumBirds() {};

practice:

private boolean playing;
private Boolean dancing;
public boolean isPlaying() { return playing; }
public boolean getPlaying() { return playing; }
public Boolean isDancing() { return dancing; }

public String name;
public String name() { return name; }
public void updateName(String n) { name = n; }
public void setname(String n) { name = n; }


DIFFERENCE boolean AND Boolean GETTERS AGAIN


boolean uses is or get
Boolean uses only get


WHAT IS THE INHERITANCE OR THE IS-A RELATIONSHIP TEST


the object-oriented design of an object being of a certain data type: 
the is-a relationship
instanceof is the java code implementation of is-a relationship


HOW DOES IS-A WORK IN PRACTICE


this not a code driven compiler issue but a logical issue
structure your data logically so that is-a always makes sense in 
all of the relationships your data has
make use of interfaces to give certain objects extra properties
without making all the is-a relationships nonsense

bad example:

Pet
|_Cat
|_Tiger //a Tiger is not a Pet logically

try to fix it:

Feline
|_Tiger
|_Pet
	|_Cat //makes sense so far!
	|_Dog //oh-oh, a Dog is-a Pet is-a Feline? Nope...

Pet is a special kind of Animal, so turn it into an interface:

Animal
|_Dog (implements Pet)
|_Feline
  |_Cat (implements Pet)
  |_Tiger


WHAT IS THE HAS-A RELATIONSHIP


the property of an object having a named data object or primitive as 
a member


IN OBJECT COMPOSITION WHAT ACCESS DO THE HAS-A OBJECTS NEED TO HAVE


public else classes outside the package can not access them since we 
are not talking inheritance here

if a class has-a public object from another class as a protected or 
public object then its children also have it


HAS-A IS ALSO KNOWN AS


object composition test


EXAMPLE


class Bird {} ---has-a--> class Beak {}
beak : Beak
A Bird is not a Beak or vice versa
A Bird has-a Beak


WHEN DO CHILDREN OF BIRD ALSO HAVE-A BEAK


when the Beak field is protected or public, then any child also has-a 
Beak thanks to inheritance


WHAT IF THE FIELD IS PRIVATE


then has-a is not inherited since private fields are not inherited


LOGICALLY, HOW CAN A HAS-A TEST FAIL WHEN IS-A PASSES


Primate (has-a protected Tail)
|_Monkey (is-a Primate and therefor has-a Tail)
|_Chimp (is-a Primate and therefor has-a Tail)

but Chimps don't have tails ...


SO, OBJECT COMPOSITION, WHAT IS IT


constructing a class using references to other classes to reuse 
functionality
new class has-a older class and its functionality
new class calls method but method body is in old class


HOW IS OBJECT COMPOSITION AN ALTERNATIVE TO INHERITANCE


because sometimes you dont want to extend a class but still need that
other class' functionality
so you just use its members if you can, meaning

fields that are public or protected


BUT WHY NOT JUST USE INHERITANCE


because sometimes classes dont logically inherit each other
WebbedFeet and Flippers have no relation
A Penguin has both though! So Penguin refers to the other two, but not
with inheritance. And Flippers can be reused without worrying that 
Penguin might pose problems for other new classes.


SO WHY IS INHERITANCE STILL AROUND


because of the powerful mechanics of automatically inheriting stuff
and method overloading without having to explicitly typing it out

Both are good and useful!


WHICH RELATIONSHIP TYPE DO INHERITANCE AND OBJETC COMPOSITION USE


inheritance uses

is-a

object composition uses

has-a


WHAT ARE DESIGN PATTERNS


general solutions to common software problems, like getters/setters or
singletons


WHAT ARE CREATIONAL PATTERNS


a software design pattern that manages creation of objects in an app


WHAT IS LEVEL OF INDIRECTION


solve a software design problem by conceptually separating the task
into multiple levels

example:

letting users create objects not directly with new() but with more 
layers of constructors/builders etc


WHAT IS THE SINGLETON PATTERN


creational pattern used to create only one object in memory in an app
all classes and threads share this one object (singleton)


WHAT ARE THE SINGLETON RULES


1 all constructors are private
2 make a private static instance of the class
3 public static access method for the instance


IS THE NAME 'INSTANCE' PART OF THE SINGLETON DEFINITION


no, often named instance/getInstance() but this is def not required


WHY IS A SINGLETON CLASS EFFECTIVELY FINAL


because all constructors are private
no subclass can call super() on the singleton class


TWO WAYS TO INSTANTIATE A SINGLETON DESIGN PATTERN


1 on one line:
	private static final HayStorage instance = new HayStorage();
2 in a static initializer block:
	 private static final StaffRegister instance;     
	 static {        
	 	instance = new StaffRegister();        
	 	// Perform additional steps     
 	}


WHAT IS THE BENEFIT ON OPTION 2


1 you can add lines to execute right after creating the object
2 you can catch exceptions and deal with it


HOW TO LAZY INSTANTIATE A SINGELTON (WAY #3)


3 on calling getInstance() you check if instance == null and if true,
create it then and return instance
benefit is reduced app load time and mem usage


WHAT ARE 2 DOWNSIDES OF LAZY INSTANTIATION


1 it is not thread safe. 2 calls simultaneously to create an object
2 delay on first startup


WHY IS LAZY INSTANT NOT THREAD SAFE


because creating a singleton that way, you can not apply final
with 1 and 2 you make the instance final


WHY CANT YOU APPLY FINAL HERE


private static VisitorTicketTracker instance;
public static VisitorTicketTracker getInstance() {      
	if(instance == null) {         
		instance = new VisitorTicketTracker();  // NOT THREAD-SAFE!
	}
	return instance;   
}
A final static variable has to be assigned a value at the latest on 
class initialization in a static initializer!


HOW CAN YOU FIX THE PREVIOUS PROBLEM


using synchronized keyword on the getInstance() method to prevent 
simultaneous thread access on startup


WHAT IS THE IMMUTABLE OBJECTS PATTERN


a creational pattern for objects whose state does not change after 
creation: read-only objects! like String


WHAT IS THE COMMON STRATEGY FOR CREATING AN IMMUTABLE OBJECT


1 use a constructor to set all properties of the object
2 all instance variables are private and final
3 no setters
4 referenced mutable objects are not allowed to be modified&accessed
5 prevent methods from being overridden


WHAT DOES 4 MEAN


When your immutable object has references to other objects as fields.
Users cant re-assign the object, but they can still alter the object.
So, make sure NOT to make methods that modify the objects referenced.
Instead, provide methods that return specifiec values of the object,
but never the object itself.
import java.util.*
public final class Animal {   
	private final String species;   
	private final int age;   
	private final List<String> favoriteFoods;   
	public Animal(String species, int age, List<String> favoriteFoods) {
      this.species = species;      
      this.age = age;      
      if(favoriteFoods == null) {         
      	throw new RuntimeException("favoriteFoods is required");      
      }      
      this.favoriteFoods = new ArrayList<String>(favoriteFoods);
  }   
  public String getSpecies() { return species; }   
  public int getAge() { return age; }   
  public int getFavoriteFoodsCount() { return favoriteFoods.size(); }
  public String getFavoriteFood(int index) { 
  	return favoriteFoods.get(index);   
}}


BAD EXAMPLE GOOD EXAMPLE OF 4


this.favoriteFoods = favoriteFoods; SUPERBAD!!!
this.favoriteFoods = new ArrayList<String>(favoriteFoods);

public int getFavoriteFoods() { return favoriteFoods(); } SUPERBAD!!!
public int getFavoriteFoodsCount() { return favoriteFoods.size(); }



WHAT PROBLEM DOES THE BUILDER PATTERN SOLVE


creating objects that require numerous values to be set at the time the 
object is instantiated


WHAT IS THE BUILDER PATTERN


A way to construct objects using a secondary class that takes care
of all the parameters that may grow over time. Set default, 
exceptions and such without breaking older code.


HOW IS A BUILDER PATTERN COUPLED 


tight coupling, the Builder needs direct knowledge of the main class,
so they usually exist as static nested classes


EXAMPLES


AnimalBuilder duckBuilder = new AnimalBuilder();
duckBuilder   
.setAge(4)   
.setFavoriteFoods(Arrays.asList("grass","fish"))
.setSpecies("duck");
Animal duck = duckBuilder.build();

Animal flamingo = new AnimalBuilder()   // not even builder instance!
.setFavoriteFoods(Arrays.asList("algae","insects"))   
.setSpecies("flamingo")
.build();

public Animal build() {	
	return new Animal(species,age,favoriteFoods); 
}


WHAT PROBLEM DOES THE FACTORY PATTERN SOLVE


write code that creates objects in which the precise type may not be 
known until runtime

complexity of creation
selecting which subclass to use
loose coupling the underlying implementaion


FACTORY PATTERN EXAMPLE


//abstract Class or Interface Food exists
//several Food classes that extend/implement the above
public class FoodFactory {   
	public static Food getFood(String animalName) {      
		switch(animalName) {         
			case "zebra": return new Hay(100);         
			case "rabbit": return new Pellets(5);         
			case "goat": return new Pellets(30);         
			case "polar bear": return new Fish(10);      }      
			default: throw new UnsupportedOperationException
				("Unsupported animal: "+animalName);
}}
public class ZooKeeper {   
	public static void main(String[] args) {      
		final Food food = FoodFactory.getFood("polar bear");
    food.consumed();   
}}


IS THIS TIGHT OR LOOSE COUPLING


loose, because FoodFactory or Keeper dont care what food there is,
as long as there is food for the animal they have.


DO THE FOOD CLASSES NEED PRIVATE CONSTRUCTORS


they cant! else you cant new Food() them


STUPID EXAM QUESTIONS:

Statement: A reference to an object may be cast to a subclass of the 
object without an explicit cast.

Answer wrong: A reference to an object requires an explicit cast if 
referenced with a subclass, so A is incorrect.

Answer right: If the cast is to a superclass reference, then an 
explicit cast is not required, so C is correct.

Superclass super = sub;
reference to object 
so object to ref doesnt need a cast if the ref is a subclass?
super object to subclass ref?










----------------     [[[CHAPTER 3 ]]]  --------------------p.104/156










WHAT CAN AN ARRAY AND AN ARRAYLIST HOLD


array: objects and primitives
arraylist: not primitives!


WILL THIS WORK


List<String> list = Arrays.asList(array);
list.remove(1);

no, you will get UnsupportedOperationException
it is a List backed by an Array and you can change objects, not size 


AUTOBOXING BYTE AND SHORT - WHAT TO LOOK OUT FOR


you need a cast to those values

new Byte((byte) 1);
new Short((short) 1);


GENERICS - HOW TO USE


1 <T> on class or interface or method
2 usable in entire class
3 method can override <T> or use class <T>
4 type erasure means compiler removes <T> puts in Object and (casts)


WHAT IS A FORMAL TYPE PARAMETER


<T>


WHEN WILL YOU GET COMPILER ERROR WITH METHOD FORMAL TYPE PARAMETER


when there is no Class<T> parameter, but your method does use it
and you dont specify the FTP before the return type
example:
class Lol {
	public static <T> T identify(T t) { return t; }
	public static     T   noGood(T t) { return t; }
}


KNOW THIS LEGAL SYNTAX


specify <T> before calling method

how?

class Box{}
	<T> T ship(T t) {}
Box.<String>ship("package");
Box.<String[]>ship(args);


HOW DID JAVA USE GENERIC COLLECTIONS BEFORE GENERICS


with Object and cast everything
this is still how java works: type erasure + cast everything for you


WHAT HAPPENS WITH GENERIC COLLECTION WITHOUT GENERICS


compiler WARNING about raw collection type because thats asking 
for trouble
List list = new ArrayList(); <- this uses Objects = compiler warning


DO YOU GET A WARNING AND WILL THIS EXAMPLE WORK


class Dragon {}
class Unicorn {}
public class LegacyDragons {
	public static void main(String[] args) {      
		List unicorns = new ArrayList();      
		unicorns.add(new Unicorn());      
		printDragons(unicorns);   
	}   
	private static void printDragons(List<Dragon> dragons) {      
		for (Dragon dragon: dragons) {
			System.out.println(dragon);    
} } }

You will get a compiler warning because java sees you using raw type.
raw type = List unicorns = new ArrayList();
It will not generate a compiler error because of the raw type.
In this case you will get a ClassCastException on for(Dragons d)


WHY AN EXCEPTION ON THAT SPECIFIC LINE


because java implicitly inserts a (Dragon) cast on that line and java
cant cast from a Unicorn to a Dragon, thats why


WHATS THE PROBLEM HERE

1:    public class LegacyAutoboxing {
2:       public static void main(String[] args) {
3:          java.util.List numbers = new java.util.ArrayList();
4:          numbers.add(5);
5:          int result = numbers.get(0);
6:       }
7:   }

numbers is a raw type List
add(5) autoboxes to an Integer no problem to store it
but java still sees a List of Objects and you cant unbox an Object
to a primitive int, so you get a compiler error at least


WHAT HAPPENS IF YOU UNBOX WITHOUT GENERICS


Unboxing gives a compiler error when generics are not used.
can not unbox an Object


WHAT IS THE PROBLEM HERE


4:    List<Integer> numbers = new ArrayList<>();
5:    numbers.add(new Integer(42));
6:    List<Object> objects = numbers;
7:    objects.add("forty two");
8:    System.out.println(numbers.get(1));


you get a compiler error on line 6 because you are making 2 references
to a List with different types: List<Integer> and List<Object>
if this would be ok, you could add a String to that List via 
List<Object> and that would break the initial promise of the List
only holding <Integer>


WHAT IS THE PROBLEM HERE


Integer[] numbers = { new Integer(42)};
Object[] objects = numbers;
objects[0] = "forty two";


Java produces a clean ArrayStoreException at runtime line 3


WHAT IS THE DIFFERENCE BETWEEN PREVIOUS 2 EXAMPLES


ArrayList generics compiler error vs arrays runtime exception
Why? 
Because of type erasure. At runtime, java no longer knows what type
goes into the ArrayList, since <T> is erased and it all becomes Object
To prevent this situation, java uses the compiler with <T> to prevent
incompatible types, but doesnt have to do that with arrays.


USING GENERICS - WHEN WILL YOU GET A COMPILER ERROR


generics have to match exactly or else compile error
can not even use proper subclasses, exact means exact
supply List<String> to method that needs List<Object> = compile error
even though ofcourse String inherits from Object
solution? read on....


BOUNDING GENERIC TYPE - INFO


1 specifies a bound
2 unbounded (wildcard) = ?
3 wildcard with upper bound = ? extends T
4 wildcard with lower bound = ? super T

T can be a class or an interface


WHAT DO UNBOUNDED AND UPPER BOUNDED GENERICS PRODUCE + EXAMPLE


unbounded and upper bounded create LOGICALLY IMMUTABLE LISTS, cant 
add or remove items because generics have to match exactly and you 
dont know what will extend you class, java doesnt allow it!
is this a list of birds or sparrows? you dont know! no adding here

2: static class Sparrow extends Bird { }
3: static class Bird { }
4:
5: public static void main(String[] args) {
6:    List<? extends Bird> birds = new ArrayList<Bird>();
7:    birds.add(new Sparrow()); // DOES NOT COMPILE
8:    birds.add(new Bird());    // DOES NOT COMPILE
9: }

what does this really mean:
List<? extends Bird> birds = new ArrayList<Bird>();

it means birds is a List of something that extends Bird, but whatever
it is they should all be of the same thing! 
List<? extends Bird> birds = List<Bird> or List<Sparrow> but not a mix
of these classes


ANOTHER EXAMPLE
interface Flyer { void fly(); }
class HangGlider implements Flyer { public void fly() {} }
class Goose implements Flyer { public void fly() {} }
private void anyFlyer(List<Flyer> flyer) {}
private void groupOfFlyers(List<? extends Flyer> flyer) {}

WHAT LISTS CAN YOU PASS TO THESE METHODS?


List<Flyer> to either method
List<Goose> & List<HangGLider> only to groupOfFlyers
generics have to match exactly


PRACTICE


3: List<? super IOException> exceptions = new ArrayList<Exception>();
4: exceptions.add(new Exception());
5: exceptions.add(new IOException());
6: exceptions.add(new FileNotFoundException());


WHY DOESNT THE CODE ABOVE COMPILE + EXPLAIN PROCES


First, determine what 'exceptions' *could* hold:
 - a List of: List<IOException>, List<Exception> or List<Object>
 - so whatever you are going to add, it has to be able to fit in all 
 	 three Lists
 - new Exception() wont work, because that is not an IOException, it 
 	 doesn't fit in all three possible Lists
 - new IOException will work because that fits in all three types
 - new FNFException will also work, because subclass of IOException
 	 meaning it can still fit in all three types *TRICKY!!*
 	 because you can NOT instantiate the List with 
 	 new ArrayList<FileNotFoundException>();
 - remember, generics have to match exactly
 - you can add and remove objects because not logically immutable


NEW EXAMPLE


List<String> strings = new ArrayList<String>();
strings.add("tweet");
List<Object> objects = new ArrayList<Object>(strings);
addSound(strings); //add a List<String>
addSound(objects); //add a List<Object>
public static void addSound(______list) { list.add("quack"); }


CAN YOU USE List<?>

no, unbounded creates logically immutable list

CAN YOU USE List<? extends Object>

no, upper bounded creates logically immutable list

CAN YOU USE List<Object>

yes, but than you cant pass a List<String> since generics dont match


THEN WHAT DO YOU USE


List<? super String>
takes a list<string> and list<object>
lower bounded knows what the parents are unlike upper bounded


COMPILE OR NOT


these three classes are used for all below examples!!
class A {}
class B extends A { }
class C extends B { }


6:    List<?> list1 = new ArrayList<A>();
7:    List<? extends A> list2 = new ArrayList<A>();
8:    List<? super A> list3 = new ArrayList<A>();
9:    List<? extends B> list4 = new ArrayList<A>();
10:   List<? super B> list5 = new ArrayList<A>();
11:   List<?> list6 = new ArrayList<? extends A>();


9: does not compile because the list can be B or lower, A is higher
11: does not compile because you need to know the type of the 
arraylist on instantiation


METHOD PRACTICE


<T> T first(List<? extends T> list) { return list.get(0); }


the method declares a type parameter T
it takes a list of T or a subclass of T
it returns the first object of that List<T>
Could be a List of String, Number or whatever and return that type


<T> <? extends T> second(List<? extends T> list)


does not compile, because you need to know what to return, you are not
allowed to write the return type as a wildcard


<B extends A> B third(List<B> list) { return new B(); }


no compile, because you specify B as the type parameter for this method 
and it extends A, now B is no longer a class in this method and 
therefore you cant instantiate it
B can be any type that extends A, so A, B or C in this case
evil trick!!


void fourth(List<? super B> list) {}


normal use of generics


<X> void fifth(List<X super B> list) {}


no, because you are mixing a method specific type parameter with a 
wildcard. If you want to use a wildcard, you must use ?


WHAT IS THE DIFFERENCE BETWEEN THESE TWO METHODS


    void fourth(List<? super B> list) {}
<X> void  fifth(List<X super B> list) {}


WHAT IS THE DIAMOND OPERATOR AND WHEN CAN YOU USE IT


<> is diamond operator and can only be used on the right side
List<Object> list = new ArrayList<>();


FOUR COLLECTIONS : IMPLEMENTATION CLASSES + BENEFITS + RELATIONSHIP


LIST - CHARACTERISTICS


ordered and allows duplicates


LIST - CLASSES


arraylist + linkedlist


LIST - SPEEDS


ArrayList
reading is constant time but writing takes longer
LinkedList
reading and writing to first or last element is fast, but anything in 
between is slower


WHAT IS VECTOR


Old arraylist that was thread safe but slower


QUEUE - CHARACTERISTICS


Queue = specific ordering, first in first out


QUEUE - CLASSES


LinkedList and ArrayDeque


WHAT IS LINKEDLIST


implements queue and list
is a double-ended queue
insert and remove elements from front and back of queue
not as efficient as a pure de queue like Deque


WHAT IS ARRAYDEQUE


Deque is short for double-ended queue
Queue<Integer> queue = new ArrayDeque<>();
arrayDeque is a resizable array


QUEUE - SPEEDS


access and reading/writing start and end is constant time, other 
indexes are linear time


SET - CHARACTERISTICS


Set = no duplicates


SET - SPEED


adding and accessing is constant time but no order anymore


SET USES NAVIGABLE SET - RECOGNISE THESE FOUR METHODS


set.lower(10) 		

= highest value <  10 = 9

set.floor(10)			

= highest value <= 10 = 10

set.ceiling(20)		

= lowest value >= 20 = 20

set.higher(20)		

= lowest value >  20 = null since not present

lower and higher are exclusive
floor and ceiling are inclusive


MAP - CHARACTERISTICS


Map = key value pairs
	keys must be unique and not null


MAP - SPEED


hashmap adding and retrieving elements by key is constant time
no order though


HASHTABLE


dont have to know it, just recognise it, its old and thread-safe
ArrayList is to Vector what HashMap is to Hashtable (no misspelling)


        C o l l e c t i o n 
       List    Queue       Set
Arraylist LinkedList HashSet TreeSet

     M a p
HashMap TreeMap


COLLECTION METHODS


1 boolean 	add(E element)
2 boolean 	remove(Object object)
3 boolean 	isEmpty()
4 int 	  	size()
5 void 	  	clear() 
6 boolean 	contains(Object object)
7 void 	  	forEach(Consumer<? super T> action)
8 boolean 	removeIf(Predicate<? super E> filter)


ITERATOR HASNEXT AND NEXT


hasNext() checks if there is a next() without throwing exception
next() actually goes to next row


LIST METHODS

 
1 void 	  		add(int index, E element)
2 E 			remove(int index) 
3 E 				get(int index)
4 E 				set(int index, E element)
5 int 	  indexOf(Object o)
6 int  lastIndexOf(Object o)
7 void  replaceAll(UnaryOperator<E> op) 


WHAT DO INDEXOF METHODS RETURN


indexOf = first matching index or -1 if not found
lastIndexOf = last matching index or -1 if not found


WHAT IF YOU ADD INDEX THAT DOESNT EXIST


IndexOutOfBoundsException


SET : TYPES + FACTORY + TIPS


HashSet uses hash table for elements: hash + values. 
Use hashCode() to retrieve elements, fast but no ordering
TreeSet sorts in natural order using Comparable interface but takes 
longer as set gets bigger
1 Set.of(varargs)
2 Set.copyOf(set)
If you print a set, you get a random order!!!!!
1 unique hashcode = 1xequals()
no unique hashcode = many equals()


QUEUE METHODS + TIPS


1 boolean add(E element)//add E to back of queue: true or EXCEPTION
2 boolean offer(E e)  	//add E to back of queue: true or false
3 E element() 				//return next E or if empty: EXCEPTION
4 E peek()					//return next E or if empty: null
5 E remove() 				//remove + return next E or if empty: EXCEPTION
6 E poll()					//remove + return next E or if empty: null 


DEQUE METHODS

All Queue methods +
7  E pop() 					//return next E or if empty: EXCEPTION
8  void push(E e)  		//add E to front of stack or EXCEPTION
9  void addFirst/addLast(E) //add E to front or EXCEPTION
11 E removeFirst/removeLast //E or EXCEPTION
10 boolean offerFirst/offerLast //true or false
12 E pollFirst/pollLast	  //E or null if empty
13 E peekFirst/peekLast	  //E or null if empty

Queue = offer/pool/peek
Stack = push/pop/peek

Deque also has 



DIFFERENCES BETWEEN QUEUE AND ARRAYDEQUE


LIFO is 

arraydeque  (stack)

and uses 

push/pop/peek (because front of queue based)

FIFO is 

queue 

and uses 

offer/poll/peek (because back of queue based)


STACK AND QUEUE EXAMPLES


12:   Queue<Integer> queue = new ArrayDeque<>();
13:   System.out.println(queue.offer(10));  // true
14:   System.out.println(queue.offer(4));   // true
15:   System.out.println(queue.peek());     // 10
16:   System.out.println(queue.poll());     // 10
17:   System.out.println(queue.poll());     // 4
18:   System.out.println(queue.peek());     // null

12:   ArrayDeque<Integer> stack = new ArrayDeque<>();
13:   System.out.println(stack.push(10));	  // nothing because push()
14:   System.out.println(stack.push(4));    // 		returns void
15:   System.out.println(stack.peek());     // 4
16:   System.out.println(stack.pop());      // 4
17:   System.out.println(stack.pop());      // 10
18:   System.out.println(stack.peek());     // null


WHAT HAPPENS IF YOU CALL REMOVE(INT) ON A QUEUE


Queue does not have index so remove(1) is literal remove a 1 as Object
boolean remove(Object object) //from Collection
E 		  remove()					//from Queue
Queue only overloads remove() without parameter

remove() something thats not in the queue but queue is not empty = 

nothing happens!


MAP FACTORIES


1 map.of("key1","value1","key2");
2 Map.ofEntries(
	Map.entry("key1","value1"),
	Map.entry("key2","value2"));

1 compiles but crashes runtime!
2 forget 1 element and does not compile


MAP TYPES


HashMap & TreeMap


WHAT IF YOU NEED ORDER BUT NOT SORTING IN A MAP


use LinkedHashMap


MAP METHODS


1  V 				put(K key, V value)         
	//add and return null or replace and return previous value
2  V 				putIfAbsent(K key, V value) 
	//add if not present and return null, else return existing value
3  V 				remove(Object key)			 
	//return value or null
4  V 				get(Object key)          
	//return value or null
5  V 				getOrDefault(Object key) 
	//return value or default
6  V 				merge(K k, V v, Function(<V, V, V> func))
7  V 				replace(K key, V value) 
	//return previous value or null
8  void			replaceAll(BiFunction<K, V, V> func)
9  boolean 		isEmpty()
10 int 			size()	
11 void			clear()
12 Set<Map.Entry<K,V>> 	entrySet()
13 Set<K> 					keySet()
14 Collection<V>			values()
15 boolean 		containsKey(Object key)
16 boolean 		containsValue(Object value)
17 void 			forEach(BiConsumer(K k, V v))


WHAT DOES ENTRYSET() RETURN


Set of Map entries
Set<Map.Entry<K,V>>


WHAT DOES SIZE() RETURN


number of key value entries


WHAT HAPPENS IF YOU RUN MAP.CONTAINS(V) OR MAP.ADD(K,V)


compile error since those methods do not exist in the map interface


WHAT IS THE ORDER IF YOU PRINT KEYSET ON HASHMAP VS TREEMAP


hashmap uses hashCode() so there is no order

treemap sorts based on natural order using comparable

treemap.keySet() returns

keys in sorted order

treemap.values() returns

values sorted by key order!

keys are sorted not the values, thats why treemap allows null values
but not null keys


WHICH DATA STRUCTURES ALLOW NULL VALUES


those that do not sort allow null values
Treemap does not allow 

null keys but null values are ok

TreeSet does not allow 

null values

ArrayDeque does not allow null because 

null is a special value as return type for some queue methods


WHICH TYPES CALL HASHCODE()


those with hash in the name


WHICH TYPES SORT


those with tree in the name


COLLECTION TYPES CHARACTERISTICS


contain dupes?

yes: list, map(values only), queue
no: set

elements ordered?

yes: list(by index), queue(defined order)
no: map, set (hash babies)

add/remove in specific order?

yes: queue
no: list, map, set


PICK THE RIGHT COLLECTION TYPE


getting top of a stack

ArrayDeque since LIFO

sell tickets in line order (=specific order) + tell position

LinkedList since FIFO + you need an index

write names which are not unique and tell them often

list because dupes -> arraylist > linkedlist since read more than write

list unique animals

HashSet since no ordering is mentioned (most efficient set)

list unique animals alphabetically

TreeSet since no dupes and sorting

check animals based on unique identifier

HashMap lookup by key


SORTING ORDER


numbers > uppercase > lowercase


COMPARABLE VS COMPARATOR


java.lang 		vs java.util
int compareTo(T t) 	vs int compare(T a, T b)
comparable has to be implemented by the Class to sort
comparator is usable as lambda


HOW TO IMPLEMENT COMPARABLE


public class Duck implements Comparable<Duck> {
	private String name;     
	public Duck(String name) { this.name = name; }
	@override public String toString() { return name; }
	public int compareTo(Duck a) { return name.compareTo(d.name); }
	public static void main(String[] args) {
		List<Duck> ducks = new ArrayList<>();
		ducks.add(new Duck("Quack"));
		ducks.add(new Duck("Puddles"));
		Collections.sort(ducks);
		Sout(ducks.toString);
	}
}
[Puddles, Quack]


WHY IS IT USEFUL TO OVERRIDE TOSTRING IN DUCK


else you get the object id which is not useful for comparison


WHAT DOES COMPARABLE RETURN


an int
 0 = equal
<0 = a is smaller than b so it comes before
>0 = a is larger  than b so it comes after


WHEN DO YOU NEED TO CAST WITH COMPARETO


in legacy code before generics
generics mean you dont have to cast from Object to comparable class


WHAT HAPPENS IF THE RESULT IN A COMPARE IS NULL


You have to decide what happens then! 
It is common to have null always sort first, but not necessary


EXAMPLE SORTING


3:   public int compareTo(Animal a) { return id – a.id; }
9:   a1.id = 5;  
10:  a2.id = 7;  
11:  System.out.println(a1.compareTo(a2));
12:  System.out.println(a1.compareTo(a1));
13:  System.out.println(a2.compareTo(a1));

a1 vs a2 -> 5-7= -2 -> <0 so a1 is smaller than a2 and comes before
a1 vs a1 -> 5-5=  0 -> =0 so a1 is equal to a2 no change in order
a2 vs a1 -> 7-5=  2 -> >0 so a2 is bigger than a1 and comes after


WHAT DOES THE ORDER FOR COMPARETO ARGUMENTS MATTER


Remember that  id – a.id  sorts in ascending order and  a.id – id  
sorts in descending order. 


WHAT IS THE RELATION OF COMPARETO WITH EQUALS


Natural ordering with compareTo is said to be consistent with equals if
and only if x.equals(y) is true whenever x.compareTo(y) is 0.

Basically means that you should make equals and compareTo use same vars 


WHEN MUST YOU USE COMPARATOR OVER COMPARABLE


if you want to sort an object that 

doesnt implement Comparable!

or 

if you want to sort in more than one way
compareTo uses name but you also want to use weight, you need comparator

EXAMPLE

sort naturally by name:
public int compareTo(Duck d) { return name.compareTo(d.name); }

but you also want to sort by weight, you need a new method outside of
compareTo

public static void main(String[] args) {   
	Comparator<Duck> byWeight = new Comparator<Duck>() {      
		public int compare(Duck d1, Duck d2) {         
			return d1.getWeight()—d2.getWeight();      
		}   
	};
	List<Duck> ducks = new ArrayList<>();   
	ducks.add(new Duck("Quack", 7));   
	ducks.add(new Duck("Puddles", 10));   
	Collections.sort(ducks);   
	System.out.println(ducks);             // [Puddles, Quack]
   Collections.sort(ducks, byWeight);   
	System.out.println(ducks);             // [Quack, Puddles]
}

WHAT ORDER OF SORTING IS THIS 

return d1.getWeight()—d2.getWeight();

ascending because d1-d2

how to make it descending

flip d1 and d2 around -> d2-d1

what is the type of byWeight

an anonymous method so you need a semicolon at the last brace };

what is a better way to implement the Comparator

with lambdas
(d1,d2) -> d1.getWeight-d2.getWeight
(d1,d2) -> { return d1.getWeight-d2.getWeight; }


COMPARATOR HELPER STATIC METHODS FOR BUILDING COMPARATOR


1 comparing(function) 			//returns any object
2 comparingDouble(function) 	//returns double
3 comparingInt(function) 		//returns int
4 comparingLong(function) 		//returns long
5 naturalOrder()		
6 reverseOrder()


COMPARATOR DEFAULT METHODS FOR BUILDING COMPARATOR


1 reversed()
2 thenComparing(function)
3 thenComparingDouble(function)
4 thenComparingInt(function)
5 thenComparingLong(function)

EXAMPLE

Comparator<Squirrel> c = 
Comparator.comparing(Squirrel::getSpecies)   
.thenComparingInt(Squirrel::getWeight);


WHY COMPARING()


because you compare name which is a String and thats why you can
only use the Object method


WHAT DOES NATURALORDER() DO


sort uses comparable impl of object


BINARYSEARCH - REQUIREMENT & RETURN VALUE EXPLAINED


- requires sorted list
- return index of found element
- if not found, return negative index minus one of would-be index


COLLECTIONS.SORT() - HOW TO PREVENT COMPILE ERROR


static method
uses comparable compareTo on the object so must implement it

1:    import java.util.*;
2:    public class SortRabbits {
3:    static class Rabbit{ int id; }
4:    public static void main(String[] args) {
5:       List<Rabbit> rabbits = new ArrayList<>();
6:       rabbits.add(new Rabbit());
7:       Collections.sort(rabbits);
8: } }

what is the result here?

compiler error on line 7: because Rabbit does not implement Comparable


TRICKY EXAMPLES

3:    List<String> names = Arrays.asList("Fluffy", "Hoppy");
4:    Comparator<String> c = Comparator.reverseOrder();
5:    int index = Collections.binarySearch(names, "Hoppy", c);
6:    System.out.println(index);

what is wrong here?

names happens to be sorted in alphabetical order, nice!

but how are we searching? we pass in the Comparator on 5: which sorts 
in 

reverseOrder()

so now you want to search names which is ascending order with a 
comparator that makes the list sort in descending order

you do not meet the requirement for searching
searching in an unsorted List means the answer is

undefined


WHAT HAPPENS IF YOU MAKE A TREESET AND ADD AN OBJECT WHICH DOES NOT
IMPLEMENT COMPARABLE


on the line that adds the object you get an

exception

why exception and not compiler error?

runtime java makes the treeset and the treeset sorts everything it
gets but then it realizes your object is not Comparable



METHOD REFERENCE : WHAT IS IT AND WHEN CAN YOU USE THEM


shorthand notation for using lambdas


REWRITE THIS LINE TO A METHOD REFERENCE

Comparator<Duck> byWeight = 
	(d1, d2) -> DuckHelper.compareByWeight(d1, d2);

Comparator<Duck> byWeight = DuckHelper::compareByWeight;


WHAT DOES :: DO SPECIFICALLY


the lambda (d1, d2) -> DuckHelper.compareByWeight(d1, d2); takes 2 
parameters but all it does it pass them to another method

The :: operator tells Java to pass the parameters automatically
into comparebyWeight


FOUR FORMATS FOR METHOD REFERENCES


1 static methods (Collections::sort)
2 instance methods on a particular instance
3 instance methods on an instance to be determined at runtime
4 constructor (ArrayList::new)


FIS USED HERE 


1. Supplier<T> : T get()
2. Consumer<T> : void accept(T)
4. Predicate<T> : boolean test(T)


EXAMPLE - STATIC METHOD


14:   Consumer<List<Integer>> lambda1 = l -> Collections.sort(l);

rewrite this to a lambda

15:   Consumer<List<Integer>> methodRef1 = Collections::sort;

java knows the lambda parameter needs to be passed to sort()


SORT() IS OVERLOADED SO HOW DOES JAVA PICK THE RIGHT ONE


look at the variable type you are putting the mabda in
in this case its a Consumer! void accept(T), 1 arg and no return
what does sort do? 1 arg and no return is not the comparator method


EXAMPLE - INSTANCE METHOD ON SPECIFIC INSTANCE


16:   String str = "abc";  
17:   Predicate<String> lambda2 = s -> str.startsWith(s);
18:   Predicate<String> methodRef2 = str::startsWith;  

here you want to call startsWith(String) on a specific instance, namely
String str to be precise. 
startsWith(String) the instance method called
str = on the specific instance
str is already known in advance, you defined it on 16:
the lambda parameter is used as argument in the method you call on str


EXAMPLE - INSTANCE METHOD ON INSTANCE NOT KNOWN IN ADVANCE / RUNTIME


19:   Predicate<String> lambda3 = s -> s.isEmpty();
20:   Predicate<String> methodRef3 = String::isEmpty;

the lambda parameter is the instance you are going to call isEmpty() on
s is not known until runtime
this looks like method reference on static method, how does java know
the difference?

java knows String and knows the isEmpty() method is an instance method
that takes no parameters. So java uses the parameter supplied as the 
instance to call isEmpty() on


EXAMPLE - CONSTRUCTOR REFERENCE


21:   Supplier<ArrayList> lambda4 = () -> new ArrayList();
22:   Supplier<ArrayList> methodRef4 = ArrayList::new;

why is there a Supplier here?

ArrayList::new java knows it takes no arg and returns an ArrayList
T get()


REMOVEIF CAN BE FOUND WHERE


Collection interface so its a collection method!

boolean removeIf(Predicate<? super E> filter)


WHEN CAN AND CANT YOU USE METHOD REFERENCE WITH REMOVEIF()
 

depends on the specific method used to test and how many parameters 
it wants
removeIf takes a Predicate and Predicate only wants 1 arg 
so if your test method requires 2 you cant use method reference!

removeIf condition == true
list.removeIf(s -> s.startsWith("A"));

you call startsWith(String) on s, where s is the instance
but startsWith also wants an argument, that makes 2


trick question: you cant use method reference here because the
 Precidate only wants 1 value but startWith needs to be called 
 on 1 value but takes another value to work = 2, pred dont get it
list.removeIf(String::isEmpty); // this does work with methref


WHERE CAN WE FIND REPLACEALL


List interface so its a List method!

void replaceAll(UnaryOperator<E> o)

UnaryOperator takes one parameter and returns value of same type

List<Integer> list = Arrays.asList(1, 2, 3);
list.replaceAll(x -> x*2);
System.out.println(list); // [2, 4, 6]


WHERE CAN WE FIND FOREACH


Collection interface so its a collection method

void forEach(Consumer<? super E> c)

what is its purpose

faster way of looping through collections than enhanced for


CAN YOU METHOD REFERENCE FOREACH


List<String> cats = Arrays.asList("Annie", "Ripley");
//old way
for(String cat: cats)  System.out.println(cat);
//java 8 way
cats.forEach(c -> System.out.println(c));

method reference way?

consumer = void accept(T)
return nothing and take 1 arg
Sout takes 1 arg and returns nothing

so yes! java will know what to do

cats.forEach(System.out::println)


MAP.MERGE() METHOD


1 key is not in map?  dont use function and add key/value
2 key has null VALUE? dont use function and replace key's value
3 key has non-null value + mapping returns null  -> remove key
4 key has non-null value + mapping returns value -> replace value


V merge(K k, V v, BiFunction<V,V,V> func)

BiFunction:
BiFunction<T,U,R> : R apply(T,U) //R is always last because return!!!

EXAMPLE

11:   BiFunction<String, String, String> mapper = (v1, v2)
12:      -> v1.length() > v2.length() ? v1: v2;
13:
14:   Map<String, String> favorites = new HashMap<>();
15:   favorites.put("Jenny", "Bus Tour");
16:   favorites.put("Tom", "Tram");
17:
18:   String jenny = favorites.merge("Jenny", "Skyride", mapper);
19:   String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21:   System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22:   System.out.println(jenny);     // Bus Tour
23:   System.out.println(tom);       // Skyride

you create a BiFunction on line 11: with <T,U,R> all being Strings 
so it will take the first 2 parameters T and U and return the value
of the function as R, in this case v1.length() > v2.length() ? v1 : v2

v represents value so it will receive 2 values
this means it only gets called if the key Jenny is present and already
has a non-null value!

what does this line do:
18:   String jenny = favorites.merge("Jenny", "Skyride", mapper);

>it calls merge() on the Map favorites and supplies the key Jenny and 
the value Skyride
>so java will lookup the key Jenny and finds it: Jenny exists as key
>recall the 4 merge outcomes!
>key Jenny also has a value Bus Tour so the mapper will run
>Bus Tour and Skyride are now supplied to the mapper function
>mapper compares length and returns the longer one as String <R>
>this String (Bus Tour in this case) will now be the new value

what does V merge(K,V,mapper) return in this case?

Bus Tour

19:   String tom = favorites.merge("Tom", "Skyride", mapper);
Tom was a Tram, Skyride is longer so Skyride is returned as V

{Tom=Skyride, Jenny=Bus Tour}


WHAT HAPPENS IF THE KEY HAS A NULL VALUE


favorites.put("Sam", null);
String Sam = favorites.merge("Sam", "Skyride", mapper);

>it calls merge() on the Map favorites and supplies the key Sam and 
the value null
>so java will lookup the key Sam and finds it: Sam exists as key
>recall the 4 merge outcomes!
>key Sam has a null value so the mapper is NOT used and Sam gets value

if key does not exist at all, dont use mapper and just add the k/v


EXTRA

1 V compute(K, BiFunction<K,V,V>)
2 V computeIfPresent(K, BiFunction<K,V,V>)
3 V computeIfAbsent(K, Function<K,V>)

1 like merge() but clunkier
2 if key is present with value, pass K and V to mapper
3 if key or value is absent, pass K and V to mapper

1: find key, use K and old V in mapper for new V, if V is null: remove 
key or leave as is, replace old V with new V


EXAM QUESTION STUFF


> Array & Arrays are 

not Collections!

> So, element with unique String is a

map and not set ...

> if you create a raw collection of Objects, you need to loop

through Objects and not something else, no compile
List list = new ArrayList(); for (String s: list) 

> Iterator with queue is bad? use while()? the order is not guaranteed
so while you expect a certain order, if you use Iterator the order
is undeterminable until runtime

> public class Hello<T> {
	new Hello<String>("hi")); 	//perfect use!
	new Hello("hi"));				//compiler warning for not using <>!
}

> String implements Comparable?  Arrays.sort(values, new MyComparator()?

yes to both!

> new ArrayList<>(10) doesnt matter at all?

correct, it is initial capacity but will be extended as necessary

> binarySearch when undefined

you need to sort and search the same way, asc or desc, not a mix

> Generic<String> g = new Generic_______(); <> <T> <?>

<?> is not allowed on right side
<T> T is not a String so no compile
<> is normal use

> class C {} class D<C> {} means

In class D a C is the formal type parameter and can no longer refer to
class C! No more new C(); in D

> Map m = new HashMap(); m.put(123, "456"); 
System.out.println(m.containsKey("123")); ?

[false] because a 123 is Integer and not String

> public static T identity(T t) {} where does <T> go

always before return type!

> Set<String> s = new HashSet<>();
s.add("lion");s.add("tiger");s.add("bear");
s.forEach(_______);  

s is already defined so you can't use it again!!!!!!
 s  -> System.out.println(s)  //correct but wrong
(s) -> System.out.println(s)  //correct but wrong :(














----------------     [[[CHAPTER 4]]]  ----------------------p.172/224










TOSTRING() ON LAMBDA


functionalinterface.BuiltIns$$Lambda$1/0x0000000800066840@4909b8da
      package        class  $$ means class doesnt exist in filesystem


FUNCTIONAL INTERFACES SIGNATURE AND WHEN TO USE THEM + EXAMPLE


1 Supplier<T> T get()
	> when you want to generate or supply values without input
	> LocalDate.now()
2 Consumer<T> void accept(T)
	> when you want to use values but not get anything back
	> System.out.println(x)
3 Predicate<T> boolean test(T)
	> used for filtering and matching
	> String::isEmpty
4 Function<T,R> R apply(T)
	> when you want to transform one type into something else
	> last parameter supplied is always the R
	> (s) -> s.length()  = string to int
5 UnaryOperator<T> extends Function<T,T> T apply(T) 
6 BinaryOperator<T> extends BiFunction<T,T,T> T apply(T t1, T t2)
	> when you want to change the current value but keep the same type
	> (s1,s2) s1.concat(s2)
BiVersions of 2,3,4 use extra parameters U etc


WHAT ARE THE CORRECT FI HERE
6: _______<List> ex1 = x -> "".equals(x.get(0));
7: _______<Long> ex2 = (Long l) -> System.out.println(l);
8: _______<String, String> ex3 = (s1, s2) -> false;
9: _______<String, String> b1 =  String::startsWith;
10:_______<String, String, String> b1 =  String::concat;
11:_______<String> b1 =  String::concat;


1 param, return boolean = predicate
1 param, return void    = consumer
2 param, return boolean = BiPredicate
2 param, return boolean = BiPredicate (startsWith needs 2 param)
3 param, return String  = BiFunction<S,S,S>
1 param, return String  = BinaryOperator<S>


WHAT IS WRONG HERE
6: Function<List<String>> ex1 = x -> x.get(0);
7: UnaryOperator<Long> ex2 = (Long l) -> 3.14;
8: Predicate ex4 = String::isEmpty;


Function needs 2 param, here there is only 1
unary returns same type, here long becomes double
predicate without generic = Object, isEmpty does not exist on object


WHICH FI IS IT PRACTICE


1 Returns a String and takes no parameter
2 Returns a Boolean and takes a String
3 Returns an Integer and takes 2 Integers


1 Supplier<String>
2 Function<String, Boolean>
3 BinaryOperator<Integer> or BiFunction<Integer,Integer, Integer>


WHY IS 2 NOT A PREDICATE


Because Predicate returns a boolean not a Boolean ...


CONVENIENCE METHODS FOR FUNCTIONAL INTERFACES + EXPLAIN


FI method(FI)
1 a1.andThen(a2)
2 a1.compose(a2)
3 predicate: p1.and(p2) p1.or(p2) p1.negate()

1 exists for consumer and function
2 exists for function


DIFFERENCE ANDTHEN AND COMPOSE


andThen uses parameter independently
compose chains results together
compose uses PARAMETER FIRST f2.compose(f1) <- f1 first THEN f2


OPTIONAL FACTORY METHODS


1 Optional.empty
2 Optional.of(Object o)
3 Optional.ofNullable(value) -> value==null ? empty() : of(value)


OPTIONAL METHODS


1 get() = get value or throw exception
2 ifPresent(Consumer) = use value if present or nothing
3 isPresent() = check for value return true or false
4 orElse(T other) = returns value if present, otherwise return other 
5 orElseGet(Supplier) = return value, or invoke supp with other T
6 orElseThrow() = throw NoSuchElementException
7 orElseThrow(Supplier)   (() -> new IllegalStateException) 


WHAT IS IMPORTANT WHEN YOU USE A SUPPLIER METHOD HERE


return types have to match if you want to return the supplier


WHAT IS THE CORRECT SYNTAX WHEN THROWING AN EXCEPTION HERE


Optional.orElseThrow( () -> new WhateverException);
>>>> NOT: throw new WhateverException, because throw is generated
>>>>      by orElseThrow(Supplier s)


WHAT IS THE DIFFERENCE BETWEEN ORELSEGET(SUPP) AND ORELSETHROW(SUPP)


you have to check the type of the Optional! if its an Optional<Double> 
and you use orElseGet(Supp), you have to return a double with the 
supplier, you cant throw an exception. For exception you throw
orElseThrow(Supp) don't mix these 2 up


STREAMS BASICS


1 source
2 zero or more intermediate operations
3 exactly one required terminal operation


UNTIL WHEN CAN A STREAM BE USED


a stream after terminal can not be used again


STREAM LAZY EVALUATION


streams only run if the terminal operation is run


STREAM FACTORY + FINITE & INFINITE EXAMPLES


1 Stream.empty();
2 Stream.of(varargs);
3 coll.stream();
4 coll.parallelStream();
5 Stream.generate(supplier)
6 Stream.iterate(seed, unaryOperator)
7 Stream.iterate(seed, predicate, unaryOperator
19: Stream<Integer> oddNumberUnder100 = Stream.iterate(
20:    1,                // seed
21:    n -> n < 100,     // Predicate to specify when done
22:    n -> n + 2);      // UnaryOperator to get next value from prev


WHY CANT YOU LOOP THROUGH A STREAM


Stream doesnt implement Iterable


TERMINAL STREAM OPERATIONS


1 long 			count()
2 Optional<T> 	min(Comparator<? super T> comparator);
3 Optional<T> 	max(Comparator<? super T> comparator);
4 Optional<T> 	findAny()
5 Optional<T> 	findFirst()
6 boolean 		anyMatch(Predicate <? super T> predicate)
7 boolean 		allMatch(Predicate <? super T> predicate)
8 boolean 		noneMatch(Predicate <? super T> predicate)
9 void 			forEach(Consumer<? super T> action)
10 Optional<T> reduce(BinaryOperator<T> accumulator)
11 T 				reduce(T	identity, BinaryOperator<T> accumulator)
12 <U> U 		reduce(U identity, 
							 BiFunction<U,? super T,U>	accumulator,  
							 BinaryOperator<U> combiner)
13 <R> R 		collect(Supplier<R> supplier,
							  BiConsumer<R, ? super T> accumulator,
							  BiConsumer<R, R> combiner)
14 <R,A> R 		collect(Collector<? super T, A,R> collector)


HOW CAN YOU DESCRIBE COLLECT()


collect() is a mutable reduction to for example StringBuilder or 
ArrayList


WHAT DO MIN/MAX/FINDANY/FINDFIRST RETURN ON EMPTY STREAM


Optional.empty();


WHY 3 REDUCE VERSIONS


normally reduce(identity, accumulator) is adequate
sometimes you want to know if the stream returns something that not
happens to be the identity, so you return an Optional which can
be empty
the 3 param version is for parallel operations to combine the result
in the end

Stream<Integer> stream = Stream.of(3, 5, 6);
BinaryOperator<Integer> op = (a, b) -> a * b;
System.out.println(stream.reduce(1, op);
System.out.println(stream.reduce(1, op, op));

both print 90 but the second one is parallel proof


REDUCE EXAMPLE


Stream<String> stream = Stream.of("w", "o", "l", "f!");
int length = stream.reduce(
		0,  				   		//default value if stream is empty
		(i,s) -> i+s.length(), 	//int + string.length
		(a,b) -> a+b); 	   	//combine current + previous values
);


COLLECT EXAMPLE


Stream<String> stream = Stream.of("w", "o", "l", "f!");
String name = stream.collect(
	StringBuilder::new,			//supplier
	StringBuilder::append,		//accumulator
	StringBuilder::append);		//combiner produces "wolf"
TreeSet<String> tree = stream.collect(
	TreeSet::new,					//initialize with a new TreeSet
	TreeSet::add,					//add the next element + order it
	TreeSet::addAll);				//add the accumulated TreeSet to final Set
System.out.print(tree); 		//[f,l,o,w]

TreeSet<String> tree = stream.collect(
	Collectors.toCollection(TreeSet::new)); //collect with a Collector
Set<String> tree = stream.collect(
	Collectors.toSet());


WHAT IS THE DIFFERENCE IN RETURN FROM LAST 2 METHODS


TreeSet version is sorted while Set version is random order anytime


WHY DOES COLLECT() HAVE 2 ADD() PARAMETERS


the first param supplier is the placeholder for the accumulator
the second param adds the stream elements to the placeholder
the third param adds everything to a new collection in case of 
parallel operations


WHICH SET IMPLEMENTATION DO YOU GET WITH TOSET()


you dont know! there is no guarantee, but usually HashSet


WHAT DO INTERMEDIATE STREAMS RETURN


Streams


COMMON INTERMEDIATE STREAM OPERATIONS

 
1 	   Stream<T> filter(Predicate)
2 	   Stream<T> distinct() 				//calls equals on ALL objects
3 	   Stream<T> limit(long maxSize)
4  	Stream<T> skip(long n)   
5 <R> Stream<R> map(Function<T,R>)
6 <R> Stream<R> flatMap(Function<T,Stream<R>>)   
7 	   Stream<T> sorted()					//in natural order
8 	   Stream<T> sorted(Comparator)
9 	   Stream<T> peek(Consumer) 			//returns original stream, 
										 			but you can alter it!


HOW TO NOT USE METHOD REFERENCES WITH A COMPARATOR WITH SORTED()


s.sorted(Comparator.reverseOrder());
s.sorted(Comparator::reverseOrder);
	a method reference is used to implement the SAM of a FI
	reverseOrder() is static method in Comparator, not the SAM
	Comparator has a SAM with 2 parameters and returns an int
	reverseOrder() does not use any parameters and returns a 
	Comparator, so the lambda fails and does not compile


WHICH PRIMITIVE STREAMS ARE THERE AND FOR WHICH TYPES


> IntStream > int byte short char
> DoubleStream > float and double
> LongStream > long


PRIMITIVE STREAM METHODS


1 all the Stream<T> methods
2 Stream<T> 			 					boxed()
3 OptionalDouble          				average()
4 OptionalInt/Long/Double 				max()
5 OptionalInt/Long/Double 				min()
6 int/long/double         				sum()
7 Int/Long/DoubleStatisticsSummary 	summaryStatistics()
8 Int/LongStream 							range(int/long a, int/long b)
9 Int/LongStream 							rangeClosed(int/long a, i/l b)


STREAM MAPPING METHODS


same Stream to same Stream

	= map()

Double/Int/Long to Stream<T>

 	= mapToObj()

Any other mapping streams

	= mapToDouble()
     mapToInt()
     mapToLong()
     flatMapToDouble()
     flatMapToInt()
     flatMapToLong()


STREAM MAPPING FUNCTIONS AS THE MAPPING PARAMETER


Stream to Stream

 = Function

Stream to Double/Int/Long

 = ToDoubleFunction ToIntFunction ToLongFunction

Double/Int/Long to Stream

 = DoubleFunction IntFunction LongFunction

Int/Long/Double to itself

 = Int/Long/DoubleUnaryOperator

Int/Long/Double to Int/Long/Double

 = TypeToTypeFunction LongToIntFunction DoubleToLongFunction etc


HOW TO CREATE A STREAM<T> FROM A PRIMITIVE STREAM


1 Stream<T> stream = primitiveStream.mapToObj(x -> x);
2 Stream<T> stream = primitiveStream.boxed();


HOW TO CREATE A PRIMITIVE STREAM FROM A STREAM<T>


IntStream ints = list.stream().flatMapToInt(x -> IntStream.of(x));


DIFFERENCE BETWEEN OPTIONAL<DOUBLE> AND OPTIONALDOUBLE?


Optional<Double>

 = for Double wrapper class

OptionalDouble

 = for double primitive

Optional<Double> get() 
     vs 
OptionalDouble getAsDouble() / getAsInt() / getAsLong() 
average() is ALWAYS OptionalDouble and returns PRIMITIVES


EXAMPLE


5:    LongStream longs = LongStream.of(5, 10);
6:    long sum = longs.sum();
7:    System.out.println(sum); // 15
8:    DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9:    OptionalDouble min = doubles.min();


WHAT PROBLEM DOES SummaryStatistics FIX


The fact that you want to get more values from a primitive stream,
but you cant because you can only use 1 terminal operation.


SUMMARYSTATISTICS METHODS


IntSummaryStatistics stats = ints.summaryStatistics();
stats.getMin() 			//value or empty Optional
stats.getMax() 			//value or empty Optional
stats.getAverage() 		//value or empty Optional
stats.getSum() 			//value or 0
stats.getCount()			//value or 0


FUNCTIONAL INTERFACES FOR PRIMITIVES


Easy stuff to remember:
- remember the base FI list
- prefix those FIs with the primitive type
- Boolean only has a Supplier version
- no more generics, only Function<R> still has one
- return is no longer <T> but the primitive of the FI, except Function
- consumer, predicate and function do not change SAM name, rest does
- unary + bninary also change SAM name
- No Bi-versions because not used as much


BooleanSupplier 				boolean 	getAsBoolean()

DoubleSupplier 				double 		getAsDouble()
IntSupplier 					int 			getAsInt()
LongSupplier 					long 			getAsLong()

DoubleConsumer 				void 			accept(double)
IntConsumer 					void 			accept(int)
LongConsumer 					void 			accept(long)

DoublePredicate 				boolean 		test(double)
IntPredicate 					boolean 		test(int)
LongPredicate 					boolean 		test(long)

DoubleFunction<R> 			R 				apply(double)
IntFunction<R> 				R 				apply(int)
LongFunction<R> 				R 				apply(long)

DoubleUnaryOperator 			double 		applyAsDouble(double)
IntUnaryOperator 				int 			applyAsInt(int)
LongUnaryOperator 			long 			applyAsLong(long)

DoubleBinaryOperator 		double 		applyAsDouble(double, double)
IntBinaryOperator 			int 			applyAsInt(int, int)
LongBinaryOperator 			long 			applyAsLong(long, long)


WHAT IS THE DIFFERENCE BETWEEN (TO)DOUBLEFUNCTION


DoubleFunction takes a primitive double/int/long and returns an <R>
ToDoubleFunction takes a <T> and returns a double


SPECIFIC FUNCTIONAL INTERFACES FOR PRIMITIVES


ToDoubleFunction<T> 			double 	applyAsDouble(T)
ToIntFunction<T> 				int 		applyAsInt(T)
ToLongFunction<T> 			long 		applyAsLong(T)

ToDoubleBiFunction<T,U> 	double 	applyAsDouble(T,U)
ToIntBiFunction<T,U> 		int 		applyAsInt(T,U)
ToLongBiFunction<T,U> 		long 		applyAsLong(T,U)

DoubleToIntFunction 			int 		applyAsInt(double)
DoubleToLongFunction 		long 		applyAsLong(double)

IntToDoubleFunction 			double 	applyAsDouble(int)
IntToLongFunction				long 		applyAsLong(int)

LongToDoubleFunction			double 	applyAsDouble(long)
LongToIntFunction				int 		applyAsInt(long)

ObjDoubleConsumer<T> 		void 		accept(T,double)
ObjIntConsumer<T> 			void 		accept(T,int)
ObjLongConsumer<T> 			void 		accept(T,long)


HOW TO SOLVE FI QUESTIONS FOR PRIMITIVES


double d = 1.0;
_________ f1 = x -> 1;
f1.applyAsInt(d);

hints:
- FI SAM name is applyAsInt so its a primitive FI 
- it takes a double and returns an int, so it is a function with no <>
- int applyAsInt(double) -> double to int?
- DoubleToIntFunction!


HOW TO CHAIN OPTIONALS TOGETHER - EXAMPLE


Optional<Integer> calculator(String s) { //calculate stuff }
Optional<Integer> result = optional.map(ChainingOpt::calculator);

What is wrong here?

map returns an Optional and calculator returns an Optional
so you get Optional<Optional<Integer>> which doesnt compile

solution?

use flatMap() to prevent getting Optional<Optional<T>>


ON THE EXAM - WHEN SHOULD YOU LOOK FOR FLATMAP


when you see one optional type transforming to another optional type


CHECKED EXCEPTIONS AND FUNCTIONAL INTERFACES


public class ExceptionCaseStudy {   
	private static List<String> create() throws IOException {      
		throw new IOException();   
}
Now we use it in a stream:ExceptionCaseStudy.create().stream().count();

nothing wrong here

but~!

Supplier<List<String>> s = ExceptionCaseStudy::create; //problem?

yes, create throws checked exception and the lambda translates to the 
SAM from Supplier and Supplier does not allow checked exceptions

= compiler error


DIFFERENCE BETWEEN COLLECTOR VS COLLECTORS


Collector is the interface and Collectors an implementation class
Collection is the interface and Collections an implementation class


COLLECTING RESULTS FROM STREAMS : USE COLLECT() IN 2 WAYS


1 collect(supplier, accumulator, combiner)
2 collect(Collector.<staticMethod>)


COLLECTORS STATIC METHODS TO USE WITH COLLECT() - MATHY METHODS


Double 							averagingDouble(ToDoubleFunction f)
Double 							averagingInt(ToIntFunction f)
Double 							averagingLong(ToLongFunction f)

DoubleSummaryStatistics		summarizingDouble(ToDoubleFunction f)
IntSummaryStatistics 		summarizingInt(ToIntFunction f)
LongSummaryStatistics 		summarizingLong(ToLongFunction f)

Double 							summingDouble(ToDoubleFunction f)
Integer 							summingInt(ToIntFunction f)
Long 								summingLong(ToLongFunctionf)

Long 								counting()


COLLECTORS STATIC METHODS TO USE WITH COLLECT() - MAPPY METHODS


Map<K, List<T>> 			groupingBy(Function f)
Map<K, List<T>> 			groupingBy(Function f,Collector dc)
Map<K, List<T>> 			groupingBy(Function f,Supplier s,Collector dc)

Map<Boolean,List<T>> 	partitioningBy(Predicate p)
Map<Boolean,List<T>> 	partitioningBy(Predicate p,Collector dc)

Collector 					mapping(Function f,Collector dc)

Map toMap(Function k, Function v)
Map toMap(Function k, Function v, BinaryOperator m)
Map toMap(Function k, Function v, BinaryOperator m, Supplier s)


COLLECTORS STATIC METHODS TO USE WITH COLLECT() - OTHER METHODS


String 			joining()				    //turn Elements into 1 String
String 			joining(CharSequence cs) //use cs as delimiter for String

Optional<T> 	maxBy(Comparator c)
Optional<T> 	minBy(Comparator c)

List 				toList()
Set  				toSet()
Collection 		toCollection(Supplier s)


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<String, Integer> map = ohMy.collect(   
	Collectors.toMap(s -> s, String::length));
	System.out.println(map); // {lions=5, bears=5, tigers=6}

HOW CAN YOU REWRITE S -> S


Function.identity();


WILL THIS WORK


Map<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k));


no, the function for K will produce duplicates 5 and 5
this will throw an exception IllegalStateException on dupe
you need to tell java what to do
suppose you want animals with same name length comma separated


HOW TO FIX THAT


add a merger function!
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
    String::length, 					//function for key with dupes
    k -> k, 							//just pass the value
    (s1, s2) -> s1 + "," + s2));	//merge duped keys with a comma


NOW YOU WANT TO CHANGE THE TYPE OF MAP USED


var ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
	String::length,    			//this is the key
	k -> k, 							//these are the values
	(s1, s2) -> s1 + "," + s2,	//merge function for duplicates
	TreeMap::new));				//supplier to put it all into
System.out.println(map); 		//{5=lions,bears,6=tigers}
System.out.println(map.getClass()); //class java.util.TreeMap


WHAT IS A DOWNSTREAM COLLECTOR


When you collect with a mappy Collectors method, you might want a 
different type for the values than List. A downstream collector is a 
second collector that can fix this for you by changing type to for 
example set


GROUPINGBY() WITH STANDARD OUTPUT


Creates a Map<K, List<String>> 
Collectors.groupingBy(
   String::length);			//1 key function non-null


GROUPINGBY() WITH DIFFERENT TYPE FOR VALUES


Creates a Map<K, Set<String>>
Collectors.groupingBy(
	String::length,			//1 key function non-null
	Collectors.toSet());		//2 downstream collector for values


GROUPINGBY() WITH DIFFERENT TYPE OF MAP AND TYPE FOR VALUES 


Creates a TreeMap<K, Set<String>>
Collectors.groupingBy(      
   String::length, 			//1 key function non-null
   TreeMap::new,				//2 supplier for return type Map
   Collectors.toSet());		//3 downstream collector for values


GROUPINGBY() VS PARTITIONINGBY()


grouping is n amount of keys, partitioning is 2 keys: true and false
grouping can change the Map type for keys with a supplier, 
partitioning can not
both can change the type for values with a downstream collector


USING COLLECTORS WITH GROUPINGBY()


Creates a Map<Integer, Long>
Collectors.groupingBy(      
	String::length,
	Collectors.counting());


USE COLLECTOR MAPPING() TO ADD ANOTHER LEVEL OF COLLECTING


var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> mappy = ohMy.collect(
Collectors.groupingBy(      
	String::length,      
	Collectors.mapping(         
		s -> s.charAt(0),          
		Collectors.minBy((a, b) -> a - b))));
		    OR
		Collectors.minBy(Comparator.naturalOrder()))));
		    OR
		minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}



CHAPTER QUESTION NOTES:

WHAT IS THE ORDER IF YOU COLLECT TO COLLECTION WITH PRIMITIVES


- if you collect to Collection, you need objects not primitives, so 
boxed() has to be before the collect()


WHEN DO YOU NEED A CAST WITH MAPTOINT/DOUBLE/LONG


- if you use mapToInt/Long/Double, you need a (cast) if the source 
type is larger than the result type double/long > int


WHICH FI IS USED FOR CONSTRUCTOR REFERENCES


- constructor references scream SUPPLIER (String:new)


> System.out.println(stream.limit(2).map(x -> x + "2"));

problem?

no terminal operation so stream never executes ... 
prints java.util.stream.ReferencePipeline$3@4517d9a3

> 
boolean b1 = stream1.anyMatch(predicate);
boolean b2 = stream2.allMatch(predicate);

boolean b1 = stream.noneMatch(predicate);
boolean b2 = stream.anyMatch(predicate);

difference? 

second pair operates a terminal on the same stream

WHAT HAPPENS THOUGH?
 
exception runtime! not compile error


> Which terminal operations on the Stream class are reductions? 
A.collect()B.count()C.findFirst()D.map()E.peek()F.sum()

A yes because you collect into one object?
B yes easy
C no because you dont look at all the objects of the stream!
D + E are intermediates
F is a reduction, but only on primitive Stream classes .....

>
What changes need to be made for this code to print the string 12345? 
(Choose all that apply.)
Stream.iterate(1, x -> x++).limit(5).map(x -> x).collect(
	Collectors.joining());
A.Change Collectors.joining() to Collectors.joining("").
B.Change map(x -> x) to map(x -> "" + x) .
C.Change x -> x++ to x -> ++x.
D.Add forEach(System.out::print) after the call to collect().
E.Wrap the entire line in a System.out.print statement.
F.None of the above. The code already prints 12345.

B is needed because joining expects Strings, not Integers.
E is needed to print the resulting String!
C is needed because (1, x -> x++) means a 1 is supplied and afterwards
  it gets incremented to 2, but that 2 is discarded! That means you 
  have an infinite stream of 1s. 
  If you do (1, x -> ++x) you increment the 1 first and then pass it 
  on, so 1->2->3->4 etc

> BinaryOperator spells out binary. 
The other functional interfaces use the prefix Bi.


>
Stream.of(l1, l2, l3)
	.map(x -> x + 1)  
	.flatMap(x -> x.stream())
	.forEach(System.out::print);

the map operation expects an Integer but gets a List<Integer>.
The compiler sees this and reports an error, you dont go to runtime.

>
4:    Stream<Integer> s = Stream.of(1);
5:    IntStream is = s.mapToInt(x -> x);
6:    DoubleStream ds = s.mapToDouble(x -> x);
7:    Stream<Integer> s2 = ds.mapToInt(x -> x);
8:    s2.forEach(System.out::print);

4 uses autoboxing and is fine
5 uses unboxing and is fine
6 will this work? would double d = 1; work?

yes! so its fine

7 will this work? would int i = d; work?

no! double is bigger than int, so you need a cast


> Map<boolean, String>

Primitives are not allowed as generics and map needs 2 generics so
compiler error

> Collectors.groupingBy(b -> b.startsWith("c")))

is this ok? its a boolean function ...

yeah its ok, groupingBy needs a Function R apply(T) and anything goes

> a FI with wrong number of generics does not compile
Function<String> does not compile
















---------------  [[[CHAPTER 5]]] -------------------------p.234/286











WHERE ARE THE DATE AND TIME CLASSES


import java.time.*


OUTPUT EXAMPLES OF .NOW() OF ALL 4 CLASSES


2015–05–25
09:13:07.768
2015–05–25T09:13:07.768
2015–05–25T09:13:07.769–04:00[America/New_York]


CONVERT BETWEEN UTC AND GMT


UTC = local time with an offset
GMT is a zone in Europe for time zone zero
substract UTC offset from time
2015–06–20T07:50+02:00[Europe/Paris]   // GMT 2015–06–20 5:50
2015–06–20T06:50+05:30[Asia/Kolkata]   // GMT 2015–06–20 1:20


The time zone offset can be listed in different ways: +02:00, GMT+2, 
and UTC+2 all mean the same thing. You might see any of them on the 
exam.


CONVERT WITH GMT

2015–06–20T07:50 GMT-04:00  

// GMT 2015–06–20 11:50  

2015–06–20T04:50 GMT-07:00  

// GMT 2015–06–20 11:50


PRACTICE


2015–06–20T07:50–07:00[US/Pacific]  
2015–06–20T07:50+05:30[Asia/Kolkata]   	


14:50
02:20

difference is 12:30 


FACTORIES FOR MAKING AND FORMATTING DATES AND TIMES


LocalDateTime			.now();
LocalDate 		 		.of(2020, Month.OCTOBER, 20); 
LocalDate 				.of(2020, 10, 20);
LocalDateTime 			.format(DateTimeFormatter)
DateTimeFormatter 	.format(LocalDateTime)


INTERMITTENT ENUM PRACTICE


12:   Month month = Month.JANUARY;  
13:   boolean b1 = month == 1; 
14:   boolean b2 = month == Month.APRIL;


13: does not compile because you cant compare enum with int!
14: is false


LOCALTIME FACTORIES


LocalTime time1 =  LocalTime.of(6, 15);          // hour and minute
LocalTime time2 =  LocalTime.of(6, 15, 30);      // + seconds
LocalTime time3 =  LocalTime.of(6, 15, 30, 200); // + nanoseconds


ALL THE LOCALDATETIME METHODS


public static LocalDateTime of(
	year,month,day,h,m
	year,month,day,h,m,s
	year,month,day,h,m,s,n
	year,Month,day,h,m
	year,Month,day,h,m,s
	year,Month,day,h,m,s,n
	date, time


ZONEDDATETIME METHODS


ZoneId z = ZoneId.of("US/Eastern");
ZonedDateTime z1 = ZonedDateTime.of(2015, 1, 20, 6, 15, 30, 200, z);
ZonedDateTime z2 = ZonedDateTime.of(date1, time1, zone);
ZonedDateTime z3 = ZonedDateTime.of(dateTime1, zone);


CAN YOU USE MONTH IN ZONEDDATETIME


no, they forgot about it


CAN YOU USE CONSTRUCTORS FOR ALL THESE DATE TIME CLASSES


No, all constructors are private!! You must use factories


WILL THESE COMPILE


1 LocalDate d = new LocalDate();
2 LocalDate.of(2015, Month.JANUARY, 32)


1 no, date time zoned stuff with new() does not compile!!
2 yes, it will compile


BUT WHY


it will throw an exception at runtime since java cant check your 
Strings that easy


ARE THE DATE TIME CLASSES IMMUTABLE


yes they are, so assign the results or else its lost


LOCALDATETIME MANIPULATION METHODS


plusNanos
plusSeconds
plusMinutes
plusHours
plusdays
plusWeeks
plusMonths
plusYears
or minus ofcourse
use on correct type or else no compile


PERIOD - FACTORY METHODS


all static methods
Period.ofYears();
Period.ofMonths()
Period.ofWeeks()
Period.ofDays()
Period.of(1,0,7)  <- year month day, not weeks!


CAN YOU CHAIN PERIODS TOGETHER


no, only the last one is used since its static!


WHAT HAPPENS IF YOU CHAIN ANYWAY


Period wrong = Period.ofYears(1).ofWeeks(1);
compiler warning about this


WHATS UP WITH THE WEEKS METHOD


Period only stores years, months and days, not weeks.


WHAT DO YOU GET WHEN YOU PRINT A PERIOD


System.out.printIn(Period.of(1,2,3));
P1Y2M3D
System.out.println(Period.ofMonths(3));
P3M
System.out.println(Period.of(0, 20, 47));
P20M47D - 0 value is omitted in printing
System.out.println(Period.ofWeeks(3));
P21D


WHY NOT COMPILER OR RUNTIME ERROR


because periods are not calendars, you can have 100 months in a period


WHAT HAPPENS IF YOU ADD A PERIOD TO LOCALTIME


UnsupportedTemporalTypeException
because java doesnt know until runtime you are adding a period to
something that only has time


WHAT ARE THE FACTORIES OF DURATION


Duration.ofDays(1);
Duration.ofHours(1);
Duration.ofMinutes(1);
Duration.ofSeconds(1);
Duration.ofMillis(1);
Duration.ofNanos(1);
Duration.of(1, ChronoUnit.DAYS)


WHAT IS STORED WITH A DURATION


hours, minutes, seconds including fractionals


WHAT IS PRINTED WITH THE ABOVE FACTORIES


PT24H - PT1H - PT1M - PT1S - PT0.001S - PT0.000000001S


IS THERE A FACTORY WITH MULTIPLE ARGS


No, use the 1 arg factories for any time


HOW DOES THE LAST FACTORY WORK


generic factory using ChronoUnit
ChronoUnit implements TemporalUnit
has convenience units such as HALF_DAYS for 12 hours etc


HOW TO CHECK HOW FAR TIME IS APART WITH CHRONOUNIT


LocalTime one = LocalTime.of(5, 15);
LocalTime two = LocalTime.of(6, 30);
LocalDate date = LocalDate.of(2016, 1, 20); 
System.out.println(ChronoUnit.HOURS.between(one, two));
System.out.println(ChronoUnit.MINUTES.between(one, two));
System.out.println(ChronoUnit.MINUTES.between(one, date));

1
75
DateTimeException


WHY 1 AND 75


between() truncates and doesnt round
5.15 -> 6.30 = 1 hour or 75 minutes


EXAMPLES


7:    LocalDate date = LocalDate.of(2015, 1, 20);
8:    LocalTime time = LocalTime.of(6, 15);
9:    LocalDateTime dateTime = LocalDateTime.of(date, time);
10:   Duration duration = Duration.ofHours(6);
11:   System.out.println(dateTime.plus(duration));
12:   System.out.println(time.plus(duration));     
13:   System.out.println(date.plus(duration));     

// 2015–01–20T12:15
// 12:15
//UnsupportedTemporalException

7:    LocalDate date = LocalDate.of(2015, 1, 20);
8:    LocalTime time = LocalTime.of(6, 15);
9:    LocalDateTime dateTime = LocalDateTime.of(date, time);
10:   Duration duration = Duration.ofHours(23);
11:   System.out.println(dateTime.plus(duration)); 
12:   System.out.println(time.plus(duration));     
13:   System.out.println(date.plus(duration));     

// 2015–01–21T05:15
// 05:15
//UnsupportedTemporalException

LocalDate date = LocalDate.of(2015, 5, 25);
Period period = Period.ofDays(1);
Duration days = Duration.ofDays(1);
System.out.println(date.plus(period)); 
System.out.println(date.plus(days)); 

// 2015–05–26
// Unsupported unit: Second


WHAT DOES INSTANT REPRESENT AND WHICH TIMEZONE


a moment in GMT time zone
Instant now = Instant.now();
// do something time consuming
Instant later = Instant.now();
Duration duration = Duration.between(now, later);
System.out.println(duration.toMillis()); //1025


CAN YOU TURN A ZONEDDATETIME INTO AN INSTANT


yes, Instant removes the timezone and converts to GMT time


CAN YOU TURN A LOCALDATETIME INTO AN INSTANT


no, there is no timezone so Instant cant convert to GMT


CAN YOU GET AN INSTANT FROM EPOCH TIME


yes, because that includes a timezone GMT
Instant instant = Instant.ofEpochSecond(epochSeconds);
System.out.println(instant);  // 2015–05–25T15:55:00Z


CAN YOU MANIPULATE AN INSTANT AND WITH WHAT


yes, with unit DAYS or smaller

Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); 	// 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS);


WHAT WILL THE LAST METHOD PRINT


nothing, exception since larger than DAYS


DAYLIGHTS SAVING TIME EXAMPLE


//spring forward is 13 march 1:59am
LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); 
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); 

// 2016–03–13T01:30–05:00[US/Eastern]
// 2016–03–13T03:30–04:00[US/Eastern]


WHAT ARE THE 2 CHANGES IN THE PREVIOUS EXAMPLE


hours jumped from 1:30+1 to 3:30
offset time went from -05:00 to -04:00


ANOTHER EXAMPLE


//fall back is 6 november 1:59am
LocalDate date = LocalDate.of(2016, Month.NOVEMBER, 6);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); 
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); 
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); 

// 2016–11–06T01:30–04:00[US/Eastern]
// 2016–11–06T01:30–05:00[US/Eastern]
// 2016–11–06T02:30–05:00[US/Eastern]

also calculate GMT for these 3 times
1 5:30 GMT
2 6:30 GMT
3 7:30 GMT


WHAT HAPPENS IF YOU USE A TIME THAT DOESNT EXIST

like 13 march 2:30am
this doesnt exist because of spring forward
what time do you get?

System.out.println(dateTime);  

// 2016–03–13T03:30–04:00[US/Eastern]
java just skips time ahead to 3:30 and changes GMT offset


STRING - IS IT FINAL AND/OR IMMUTABLE


the class is final and a String object is immutable


COMPARING STRINGS AND WHY == IS NOT HANDY


4:    String s1 = "bunny";
5:    String s2 = "bunny";
6:    String s3 = new String("bunny");
7:    System.out.println(s1 == s2);        // true
8:    System.out.println(s1 == s3);        // false
9:    System.out.println(s1.equals(s3));   // true


STRING - STRINGBUILDER - STRINGBUFFER


immutable?


yes - no - no


pooled?


yes - no - no


thread-safe?


yes - no - yes


increase in size?


no - yes - yes


INTERNATIONALIZATION VS LOCALIZATION AND LOCALE


Internationalization

 = designing your program to be adaptable, but you dont have to use
 more than 1 lang or country
 use property files and DateFormat

Localization

 = actually supporting multipe locales

Locale

 = language and country pairing in java.util 


WHAT THE SHIT IS I18N AND L10N


abbreviations of big words


LOCALE DEFAULT METHOD + SYNTAX


Locale locale = Locale.getDefault();
en or en_US
lowercase language code
lowercase language code _ UPPERCASE COUNTRY code


VALID OR NOT LOCALES


US
enUS
US_en
EN


all invalid


SELECTING A LOCALE OTHER THAN DEFAULT


1 Locale.GERMAN;
2 Locale.GERMANY;
3 new Locale("fr");
4 new Locale("hi", "IN");


WHAT HAPPENS IF YOU MAKE A NON-EXISTING LOCALE


invalid locale String is allowed but since no match result is 
unexpected


LOCALE WITH BUILDER PATTERN


Locale l1 = new Locale.Builder()
	.setRegion("US")
	.setLanguage("en")
	.build();


IS THIS VALID


Locale l2 = new Locale.Builder()
	.setRegion("us")       
	.setLanguage("EN")       
	.build();

yes but dont do this ever


CAN YOU MAKE A BLANK LOCALE


yes but dont do it


HOW ARE BUILDERS USUALLY IMPLEMENTED FOR A CLASS


Usually a static nested class is used as Builder because they are 
tightly coupled.


SET LOCALE DEFAULT


Locale.setDefault(locale);


WHAT ARE RESOURCE BUNDLES AND WHERE DO YOU STORE THEM


1 The text strings are in the code. 
2 To localize, you need to externalize them in a resource bundle. 
3 This bundle is stored in a properties file with key value pairs.


HOW CAN YOU WRITE KEY VALUE PAIRS IN A PROPERTY FILE


animal=dolphin
animal:dolphin
animal dolphin


WHAT ARE OTHER SYNTAX RULES FOR PROP FILES


# or !:

	is a comment

whitespaces around the separator:

	are ignored

spaces at the beginning:

	are ignored

spaces at the end:

	are not ignored

a breakline character is:

	\

escape chars to use:

	\t and \n


SYNTAX EXAMPLE


# one comment
! another comment
key =   value\tafter tab
long = abcdefghijklm\ 
 nopqrstuvwxyz

RESULT


value → after tab
abcdefghijklmnopqrstuvwxyz


RESOURCEBUNDLE METHODS


Factory methods to create a resource bundle reference:
1 var rb = ResourceBundle.getBundle("<filename>); //uses std locale
2 var rb = ResourceBundle.getBundle("<filename>", locale);
rb now points to the resource bundle and you can get the values with:
rb.getString("<key>"); 	//get value from a key
rb.keySet(); 		   	//to get set of all keys to stream()


CAN YOU PUT TYPES OTHER THAN STRING IN .PROPERTIES RESOURCE BUNDLE


no, you need to create a java class if you want non strings


HOW TO CREATE JAVA CLASS FOR RESOURCE BUNDLES


extend ListResourceBundle
override getContents() and fill it with 2D array Object[][]


HOW TO GET RESOURCES WITH OBJECT[][]


with rb.getObject("name");
UsTaxCode class : exists

1:    package resourcebundles;
2:    import java.util.*;
3:    public class Tax_en_US extends ListResourceBundle {
4:       protected Object[][] getContents() {
5:          return new Object[][] { { "tax", new UsTaxCode() } };
6:       }
7:       public static void main(String[] args) {
8:          ResourceBundle rb = ResourceBundle.getBundle(
9:              "resourcebundles.Tax", Locale.US);
10:         System.out.println(rb.getObject("tax"));
11:      }}

to make your own java resourcebundle remember:

extend ListResourceBundle

and 

override Object[][] getContents()


HOW DOES JAVA PICK A RESOURCE BUNDLE


these steps check for .java and then .properties
1 Look for file with requested locale
2 Look for file with requested locale without country
3 Look for file with default locale
4 Look for file with default locale without country
5 Look for file with no locale, the default bundle
6 throw MissingResourceException


EXAMPLE OF # OF STEPS TO FIND LOCALE


Locale.setDefault(new Locale("hi"));
ResourceBundle rb = ResourceBundle.getBundle("Zoo", new Locale("en"));

bundle to get = "Zoo"
locale requested = "en"
default locale = "hi"
1 requested locale Zoo_hi.java
2 requested locale Zoo_hi.properties
3 default locale Zoo_en.java
4 default locale Zoo_en.properties
5 default bundle Zoo.java
6 default bundle Zoo.properties


HOW DOES THE RESOURCE BUNDLE HIERARCHY WORK


1 use the above list to find a property file
2 java will reduce the property list name to just the filename
3 if requested locale is found the default locale is never used!!
4 look for keys in the entire hierarchy


WHAT DOES THE RESOURCE BUNDLE HIERARCHY LOOK LIKE


Zoo_en_CA.properties
   Zoo_en.properties
      Zoo.properties
MissingResourceException


FORMATTING MESSAGES


Use MessageFormat class 
parses parameters into variables {0} en {1} 
MessageFormat.format(String sentence, args...);
helloByName=Hello, {0} and {1}
String format = rb.getString("helloByName");
System.out.print(MessageFormat.format(format, "Tammy","Henry"));
	//Hello, Tammy and Henry


USING PROPERTIES.CLASS


java.util.Properties
is like a HashMap that uses only strings for keys and values
Properties props = new Properties();
props.setProperty("name", "Our zoo");


PROPERTIES METHODS AND WHICH ONES TO USE


setProperty()
getProperty()
can handle values that don't exist and has a default value option:
	props.getProperty("camel"); 				//null
	props.getProperty("camel", "Bob"));    //Bob = default value
Properties inherits from Map<Object,Object> but you shouldn't use 
get()
get() does not have a default option and will not compile


LOCALIZING NUMBERS - PACKAGE + HOW TO START


in java.text
First obtain instance of NumberFormat


LOCALIZING NUMBERS - FACTORY METHODS


NumberFormat.getInstance()					//general purpose formatter
NumberFormat.getNumberInstance()			//same as getInstance()
NumberFormat.getCurrencyInstance()		//for currencies
NumberFormat.getPercentInstance()		//for percentages
NumberFormat.getIntegerInstance()		//rounds decimals
These methods can all also take a (locale)


WHAT HAPPENS IF YOU DONT SUPPLY A LOCALE TO THE INSTANCES


You use the users own default locale


METHODS TO CONVERT DATA BOTH WAYS


NumberFormat.format()   // from number to string
NumberFormat.parse()		// from string to number


ARE NUMBERFORMAT CLASSES THREAD-SAFE


no, do not store in instance or static variables


WHICH NUMBERFORMAT METHOD DECLARES WHICH EXCEPTION?


ParseException


SO WHAT TO LOOK OUT FOR WHEN YOU SEE NUMBERFORMAT.PARSE()


look at the code snippet and check if exception is handled/declared
and if the return value is (cast)


WHAT HAPPENS IF YOU PARSE 40.45 TO NL LOCALE


NL doesnt know a . in numbers, so you end up with 40!
first character that isnt a number is a formatting character and 
java stops checking from that point on
Always be aware what locales can do to your numbers.


EXAMPLES


NumberFormat nf = NumberFormat.getInstance();
String one = "456abc";
String two = "-2.5165x10";
String three = "x85.3";
System.out.println(nf.parse(one));
System.out.println(nf.parse(two));
System.out.println(nf.parse(three));


456
-2.5165
ParseException (String doesnt even start with number)


WHAT IS THE RETURN VALUE OF PARSE()


Number


WHY IS THIS IMPORTANT


Number is the parent of all wrapper classes, so (cast) is 
needed to cast to your value type.
String income = "$92,807.99";
NumberFormat cf = NumberFormat.getCurrencyInstance();
double value = (Double) cf.parse(income);
System.out.println(value); // 92807.99 
parse returns a Number, cast to Double and automatically unboxed


LOCALDATE GET METHODS


LocalDate date = LocalDate.of(2020, Month.OCTOBER, 20);
System.out.println(date.getDayOfWeek());  // TUESDAY
System.out.println(date.getMonth());      // OCTOBER
System.out.println(date.getYear());       // 2020
System.out.println(date.getDayOfYear());	// 20


DATETIMEFORMATTER STANDARD FORMATS


DateTimeFormatter 	.ISO_LOCAL_DATE
DateTimeFormatter 	.ISO_LOCAL_TIME
DateTimeFormatter 	.ISO_LOCAL_DATE_TIME
exception if you use the wrong type!

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
Sout(    date.format(DateTimeFormatter.ISO_LOCAL_DATE));
Sout(    time.format(DateTimeFormatter.ISO_LOCAL_TIME));
Sout(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));


IN WHICH PACKAGE IS DATETIMEFORMATTER


java.time.format


CUSTOM FORMAT FOR DATE AND TIME EXAMPLE


DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at'hh:mm");
M = 1
MM = 01
MMM = Jan
MMMM = January
yy = 21
yyyy = 2021
d = 5
dd = 05
h = 9
hh = 09
m = 45
s = 52
a = AM, PM
z = timezone name like Eastern Standard Time, EST
Z = timezone offeset like -0400


WHEN CAN YOU USE z AND/OR Z


z and Z only work with ZonedDateTime else exception!


EXAMPLE


DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", f);
the passed String is formatted based on f so it should fit
But it gets printed based on the locale 

System.out.println(date);          // 2015–01–02


WHAT IF THE STRING DOESNT PASS THE FORMAT


exception!


ARE THERE OVERLOADED METHODS FOR PARSE WITH A DTF


yes, 
LocalDate date = LocalDate.parse("string");
LocalDate date = LocalDate.parse("string", dtf);


WHAT HAPPENS IF NO DTF IS PASSED


default format for that type is used


LOCALIZING DATES FACTORY METHODS FOR DATETIMEFORMATTER


						FormatStyle parameter
DateTimeFormatter.ofLocalizedDate(dateStyle)
DateTimeFormatter.ofLocalizedTime(timeStyle)
DateTimeFormatter.ofLocalizedDateTime(dateStyle, timeStyle)
DateTimeFormatter.ofLocalizedDateTime(dateTimeStyle)


WHEN EXCEPTIONS WHEN USING OFLOCALIZED METHODS 


The ofLocalized method needs to parse its time or date, then its cool
If you miss a part, ofLocalized will throw an exception.
If you supply too much, it just doesnt show that part but its legal.
ofLocalizedDate(localTime) = exception
ofLocalizedDate(localDateTime) = just show date part
ofLocalizedDateTime > you need to supply date + time part else except


RECAP THE DATETIMEFORMATTER METODS


standard formats: Dtf.ISO_LOCAL_DATE_TIME etc
custom formats:   Dtf.ofPattern("MMMM dd yyyy hh m s a z Z")
custom dates:     Dtf.ofLocalizedDateTime(formatstyle)
usage:			  	dtf.format(LocalDateTime)   OR
				  		LocalDateTime.format(dtf)


WHAT IS FORMATSTYLE


found in java.time.format.FormatStyle.SHORT/MEDIUM/LONG/FULL
For the exam, you are not required to know the format of each of 
these styles.
example: DateTimeFormatter.ofLocalizedDateTime(SHORT, SHORT)


HOW TO FORMAT FOR A SPECIFIC LOCALE


insert the call with withLocale(locale)
1 dtf.format(dateTime) 							//uses default locale
2 dtf.withLocale(locale).format(dateTime)	//uses requested locale


AGAIN - PERIOD AND DURATION VALUES


period is for 

years months days

duration is for 

hours minutes seconds


GMT CONVERSION

substract thye offset from the time

05:30+03:00 -> 5:30 -  3:00 = 2:30
05:30-03:00 -> 5:30 - -3:00 = 8:30


CHAPTER QUESTIONS

> 
What is the output of the following code?
LocalDate date = LocalDate.parse("2018–04–30", 
					  DateTimeFormatter.ISO_LOCAL_DATE);
date.plusDays(2);
date.plusHours(3);
System.out.println(date.getYear() + " "  + 
						 date.getMonth() + " "+ 
						 date.getDayOfMonth());

exception or not?

A LocalDate does not have a time element. 
Therefore, it has no method to add hours, and the code does not compile.


>
String m1 = Duration.of(1, ChronoUnit.MINUTES).toString();
String m2 = Duration.ofMinutes(1).toString();
String s = Duration.of( oString();
String d = Duration.ofDays(1).toString();
String p = Period.ofDays(1).toString();
System.out.println(_____);

A.m1 == m2
B.m1.equals(m2)
C.m1.equals(s)
D.d == p
E.d.equals(p)

A&D are wrong because they dont point to the same objects on the heap
E is wrong because P and PT, also they are different TYPES

m1,m2,s all represent 1 minute, all will be printed as PT1M and s
will not be printed as PT60S


>
new Locale("IN", "hi");

is this correct?

no, not valid!
it will, however, compile and be converted to in_HI



















---------------  [[[CHAPTER 6]]] ------------------------p.284/336

















EXCEPTION HIERARCHY AND WHICH ARE CHECKED


Throwable (checked)
	-> Error
	-> Exception (checked)
		-> RuntimeException


UNCHECKED EXCEPTIONS


1  ArithmeticException 			//divide by zero
2  ArrayIndexOutOfBoundsException
3  ArrayStoreException 			//store incorrect type in array
4  ClassCastException
5  DateTimeException				//receiving invalid format for date
5  MissingResourceException	//resource bundle not found
6  NullPointerException
7  IllegalStateException		//starting a thread twice
8  IllegalArgumentException
9  NumberFormatException extends IllegalArgumentException
10 UnsupportedOperationException//add() on Arrays.asList(array);



CHECKED EXCEPTIONS


1 IOException
	2 FileNotFoundException extends IOException
	3 NotSerializableException extends IOException
4 ParseException
5 SQLException


COMPILE ERRORS WHILE CATCHING EXCEPTIONS


1 with multiple catch blocks you need to go from narrow to broad
2 in a multi-catch you can not have related classes
3 syntax for multi-catch: 
	catch (IOException | FileNotFoundException e)


MULTI-CATCH IS EFFECTIVELY FINAL - WHAT DOES THIS MEAN


if you use multi-catch, you are not allowed to reassign the 
exception reference:
try {   
	throw new IOException();
} catch(IOException | RuntimeException e) {  
	e = new RuntimeException();    // DOES NOT COMPILE
}
this would be fine for non multi-catch but still bad!!


WHICH EXCEPTIONS CAN YOU CATCH 


all runtime exceptions all the time, but only checked exceptions
that have the potential to be thrown!


CAN YOU CATCH THE SAME EXCEPTION TWICE IN DIFFERENT MULTI-CATCHES


no


CONSTRUCTORS FOR YOUR CUSTOM EXCEPTION


public class MyException extends Exception {}
1 public MyException() 						{super();}  //optional 
2 public MyException(Exception e) 		{super(e);}
3 public MyException(String message)	{super(message);}


EXCEPTION OUTPUT


1 throw new CannotSwimException();
	Exception in thread "main" CannotSwimException   
		at CannotSwimException.main(CannotSwimException.java:16)
2 throw new CannotSwimException("broken fin");
	Exception in thread "main" CannotSwimException: broken fin   
		at CannotSwimException.main(CannotSwimException.java:16)
3 throw new CannotSwimException(new FileNotFoundException("Where?"));
	Exception in thread "main" CannotSwimException:    
		java.io.FileNotFoundException: Where?   
		at CannotSwimException.main(CannotSwimException.java:16)
	Caused by: java.io.FileNotFoundException: Where?


TRY-WITH-RESOURCES


1 list resources in () after try
2 semicolon required between resources, optional at the end
3 resources are closed in reverse order when the try ends
4 both catch and finally blocks are optional
5 try-with-resources has a hidden implicit finally block
6 if you declare a finally block its called explicit finally
try (var in = new FileInputStream("data.txt");
	var out = new FileInputStream("output.txt");) {} finally {}


WHAT IS AUTOMATING RESOURCE MANAGEMENT & RESOURCE


1 resources declared in the try clause are automatically closed at 
the conclusion of the try block.
2 A resource is typically a file or a database that requires some 
kind of stream or connection to read or write data.


RESOURCE MANAGEMENT VS GARBAGE COLLECTION


if an object is no longer used (referenced), it can be garbage 
collected
if a resource is not closed, it stays open, it can not even be 
garbage collected!


RULES FOR USING A RESOURCE WITH TRY-WITH-RESOURCES


1 resource must implement AutoCloseable for the close() method
2 declare multiple resources which are closed in reverse order (;)
3 resources are only in scope within the try block


AUTOCLOSEABLE VS CLOSEABLE


1 Closeable extends AutoCloseable
2 AutoCloseable void close() throws Exception
3     Closeable void close() throws IOException

Closeable restricts to IOException and forces idempotency


WHAT IS IDEMPOTENT


means a method can be called multiple times without changing state
or having undesirable behavior on multiple runs


WHAT DOES YOUR CUSTOM RESOURCE CLASS NEED


1 implement AutoCloseable
2 override void close() method


CAN YOU USE RESOURCES YOU DECLARED BEFORE THE TRY-WITH-RESOURCES


It is possible to use resources declared prior to the 
try‐with‐resources statement


WHAT IS A REQUIREMENT OF THE RESOURCE TO USE IT BEFORE T-W-R

They have to be final or effectively final.
The syntax is just to use the resource name in 
place of the resource declaration, separated by a semicolon (;)
31: var writer = Files.newBufferedWriter(path);
32: try(writer) {  // DOES NOT COMPILE
33:    writer.append("Welcome to the zoo!");
34: }
35: writer = null; //not effectively final


WHEN DOES A RESOURCE BECOME UNAVAILABLE


if used with try-with-resources, only in the try block


WHY IS IT A BAD IDEA TO DECLARE RESOURCES BEFORE THE TRY BLOCK


might not get closed 


EXAMPLE OF WHY EXCEPTIONS AND TRY-WITH-RESOURCES IS TRICKY


public class StuckTurkeyCage implements AutoCloseable {   
	public void close() throws Exception {     
		throw new Exception("Cage door does not close");   
	}   
	public static void main(String[] args) {      
		try (StuckTurkeyCage t = new StuckTurkeyCage()) {
			System.out.println("put turkeys in");      
}}}


WHAT IS WRONG HERE


StuckTurkeyCage is a resource which on close() throws an Exception 
which is checked. That means the caller main() must handle or declare 
that exception which it does not. Compiler sees this and gives a 
compiler error. 


SOLUTIONS


try () needs to handle the Exception by catching it
main() should declare throws Exception


SUPRESSED EXCEPTIONS RULES


1 close() can be programmed to throw an exception
2 try-with-resources can also throw an exception
3 the first exception encountered is the primary exception
4 following exceptions are suppressed exceptions tacked on
5 programmer made catch block matches the primary exception
6 if the catch {} cant match the primary, exception goes to caller
7 do not look at suppressed exceptions for the catch
8 if >1 resources throw exceptions, primary is 1st reversed order
9 if an explicit finally block throws an exception you lose the others


EXAMPLE

public class JammedTurkeyCage implements AutoCloseable {   
	public void close() throws IllegalStateException {      
		throw new IllegalStateException("Cage door does not close");   
}}
15:   try (JammedTurkeyCage t = new JammedTurkeyCage()) {
16:      throw new IllegalStateException("turkeys ran off");
17:   } catch (IllegalStateException e) {
18:      System.out.println("caught: " + e.getMessage());
19:      for (Throwable t: e.getSuppressed())
20:         System.out.println(t.getMessage());
21:   }


first exeption thrown is on 16 = primary
on 17 the resource is closed and throws another suppressed exception
on 18 the primary exception is printed and
on 19 we loop through suppressed exceptions and print it with 20
caught: turkeys ran off
Cage door does not close


EXCEPTION MATCH IS IMPORTANT

22:   try (JammedTurkeyCage t = new JammedTurkeyCage()) {
23:      throw new RuntimeException("turkeys ran off");
24:   } catch (IllegalStateException e) {
25:      System.out.println("caught: " + e.getMessage());
26:   }


we throw runtime on 23 but 24 catches illegalstate, that does not 
match so catch block isnt used


THEN WHAT IS THE OUTPUT


exception in main RuntimeException: turkeys ran off
	at class location
	Suppressed: IllegalStateException: cage door does not close


RETHROWING EXCEPTIONS - WHAT IS IT


common pattern to catch and rethrow an exception:
void method() throws Exception1, Exception2
try { //throw Exception2 }
catch (Exception1 | Exception2 e) { 
	print(e); 
	throw e;    //re-throwing right here!
}


WHAT IS UGLY HERE


you get the exception list twice, once declared and once handled to
rethrow again


HOW TO FIX


java allows you to catch Exception only and it will know what 
exceptions it can get from the method throws


IF YOU ADD AN EXCEPTION TO THROWS


with multi catch you need to catch that one as well
with rethrowing you dont have to do anything


IF YOU REMOVE AN EXCEPTION FROM THROWS

with multi catch you need to remove that one as well
with rethrowing you dont have to do anything, java knows it can only
mean the remaining exceptions from throws


EXAMPLE


3: public void multiCatch() throws SQLException, DateTimeParseExc {
4:       try {
5:          parseData();
6:       } catch (SQLException | DateTimeParseException e) {
7:          System.err.println(e);
8:          throw e;
9:       } }
add/remove to/from throws = add/remove multicatch

VS

3: public void rethrowing() throws SQLException, DateTimeParseExc {
4:       try {
5:          parseData();
6:       } catch (Exception e) {
7:          System.err.println(e);
8;          throw e;
9:       } }
add/remove to/from throws = done!


ASSERTIONS VS. UNIT TESTS


assertions are for state and unittests are for behavior


ASSERT STATEMENT SYNTAX


assert  boolean_expression;
assert (boolean_expression): message;
assert is a keyword! cant be used as anything else even if disabled


EXAMPLES OF WRONG ASSERTION SYNTAX


1 assert(1);    
2 assert x -> true;    
3 assert 1==2 ? "Accept" : "Error";    
4 assert.test(5> age);
1-3 are not boolean expressions
4 is wrong syntax


CONSEQUENCE OF ASSERTION


1 if disabled nothing happens
2 if enabled and true nothing happens
3 if enabled and false throws AssertionError which ends the program


IF YOU USE -EA WITHOUT ARGUMENTS WHAT IS ASSERTED


everything but system classes (java runtime)


USING ASSERTIONS FROM COMMANDLINE


EXAM: default jvm ignores assertions
1 java -enableassertions Rectangle
2 java -ea Rectangle
3 java -ea:com.demos... my.programs.Main
4 java -ea:com.demos.TestColors my.programs.Main
5 java -ea:com.demos... -da:com.demos.TestColors my.programs.Main



CHAPTER QUESTIONS

>
public static void main(String[] args)  {   
	try {      
		throw new IOException();   
	} catch (__________________________) { }
}

A.FileNotFoundException | IOException e
C.FileNotFoundException | RuntimeException e
E.IOException | RuntimeException e

A?

no, because there is a sub/superclass relation

C?

no, because now IOException is not handled or declared anymore!

E?

yes


> memorize table 6.2 and 6.3!!!!!!!!!!!!!

> 
public class AhChoo {   
	static class SneezeException extends Exception { }   
	static class SniffleException extends SneezeException { }   
	public static void main(String[] args) throws SneezeException {
		try {         
			throw new SneezeException();        
		} catch (SneezeException e) {           
			______________           
			throw e;        
}}}

A.// leave line blank
B.e = new Exception();
C.e = new RuntimeException();
D.e = new SneezeException();
E.e = new SniffleException();

Since a single exception type is caught, only the same type of 
exception or a sub-class is allowed to be assigned to the variable in 
the catch block. 



>
public void read() throws SQLException {   
	try {     
		readFromDatabase();   
	} catch (_________________ e) {     
		throw e;   
}}
private void readFromDatabase() throws SQLException { }

A.Exception
B.RuntimeException
C.SQLException
D.SQLException | IOException
E.SQLException | RuntimeException

with rethrowing, Exception is always good because it matches the 
declared thrown exceptions

B is ok because the SQLExcepton is declared so handling is not neces

C and E are good

D is not good because

an IOException is not declared possible to be thrown!!













---------------  [[[CHAPTER 7]]] ------------------------- p.326/378














WHAT IS A THREAD


A thread is the smallest unit of execution that can be scheduled by OS
One thread can complete multiple independent tasks but only 1 at a 
time.


TASK


A single unit of work performed by a thread. 
Commonly a lambda expression.


WHAT IS A PROCESS


A group of associated threads that execute in the same, shared 
environment.

Process (Java program) has:
|_ shared memory used by
	|_Thread1	\                         /CPU1
	|_Thread2  --> OS Thread scheduler --> CPU2
	|_Thread3   /                         \CPU3



SINGLE- AND MULTITHREADED PROCESS?


SHARED ENVIRONMENT


The threads in the same process share the same memory space and can 
communicate directly with one another.
1 A process (java program)
2 has shared memory
3 x amount of threads
4 scheduled by the task scheduler to run on
5 n amount of cpus


SHARED MEMORY


Generally static variables but also instance and local variables 
passed to a thread. If one thread updates a static, all threads 
within that process have that info.


ARE ALL JAVA PROGRAMS SINGLE OR MULTITHREADED


actually multi because for java programs you always have a system 
thread for garbage collection and 1 user-defined thread to start 
main(), so 2 threads total


BUT HOW DO WE REFER TO A PROCESS WITH 1 USER-DEFINED THREAD


singlethread


SYSTEM THREAD + EXAMPLE


1 Created by the JVM and runs in the background of the application.
2 Garbage collection runs on a system thread.
3 System threads are mostly invisible to the user and throw Errors.


USER‐DEFINED THREAD


1 Created by the application developer to accomplish a specific task.
2 simple programs have 1 user-defined thread: main()
3 we call 1 user-defined thread apps: single threaded


WHAT ARE DAEMON THREADS


1 system or user-defined threads
2 one that will not prevent JVM from exiting
3 if only daemon threads are running: JVM will shut down


WHAT IS CONCURRENCY


The property of executing multiple threads and processes at the same 
time by the OS.


THREAD SCHEDULER


Determines which threads should be currently executing.
Round Robin: all threads get x amount of time in circular order using 
context switches when time is up.


CONTEXT SWITCH


The process of storing a thread's current state and later restoring 
the state of the thread to continue execution. 
Cost of a context switch by way of lost time saving and reloading a 
thread's state.


THREAD PRIORITY


1 A thread can interrupt or supersede another thread if it has a 
higher thread priority than the other thread.
2 An Integer value associated with a thread that is taken into 
consideration by the threadscheduler when determining which threads 
should currently be executing.


WHAT ARE THE THREAD CONSTANTS FOR PRIORITY


Thread.MIN_PRIORITY    1
Thread.NORM_PRIORITY   5
Thread.MAX_PRIORITY    10


WHAT HAPPENS IF TWO THREADS HAVE SAME PRIORITY


scheduler arbitrarily chooses between them


HOW DO YOU DEFINE A TASK WITH RUNNABLE


1 with FI Runnable in java.lang
2 takes no argument and returns no data
3 void run();
4 used to define task or work a thread will execute seperate from the 
main application thread
Runnable sloth = () -> System.out.println("Hello World");
Runnable snake = () -> {int i=10; i++;};
Runnable beaver = () -> {return;};
Runnable coyote = () -> {};
Runnable capybara = () -> "";
Runnable Hippopotamus = () -> 5;
Runnable emu = () -> {return new Object();};

which of these Runnables are good and which are bad? and why?


IF YOU SEE A RUNNABLE LAMBDA TAKE A PARAMETER OR RETURN SOMETHING


does not compile because void run()


HOW TO CREATE A THREAD


1 use java.lang.Thread
2 define the thread with the task
3 start task with Thread.start()


HOW TO DEFINE THE TASK THAT A THREAD INSTANCE WILL EXECUTE


1 provide Runnable object or lambda expression to Thread constructor
2 create class that extends Thread and override run()
option 1 should be used in most situations


EXAMPLES OF PREVIOUS THREAD INSTANCES


1a(new Thread(new ClassThatImplementsRunnable())).start();
1b new Thread(() -> lambda with no parameter or return value).start();
2 (new ClassThatExtendsThread()).start(); //less common

public class PrintData implements Runnable {
	@Override public void run() { // Overrides method in Runnable
		for(int i = 0; i < 3; i++)         
		System.out.println("Printing record: "+i);
	}
	public static void main(String[] args) {
		// new Thread with a Runnable Object
		(new Thread(new PrintData())).start();
   	}
}

public class ReadInventoryThread extends Thread {
	@Override public void run() { // Overrides method in Thread      
		System.out.println("Printing zoo inventory");   
	}   
	public static void main(String[] args) {
		// new class that extends Thread and overrides run()
		(new ReadInventoryThread()).start();   
	}
}


HOW DO YOU START A THREAD


Thread.start() to start in a seperate OS thread


DOES JAVA GUARANTEE ORDER OF EXECUTION + MEANING + EXAMPLE


1 Java does not garuantee order of execution on asynchronous threads
2 This means the main() thread does not wait on newly created threads
3 order is undetermined until runtime
4 order within a single thread is still ordered
2: public static void main(String[] args) {
3:    System.out.println("begin");
4:    (new ReadInventoryThread()).start();
5:    (new Thread(new PrintData())).start();
6:    (new ReadInventoryThread()).start();
7:    System.out.println("end");
8: }



HOW MANY THREADS WERE STARTED IN PREVIOUS EXAMPLE


four threads: main + 3 new Threads


WHAT IS THE RESULT ORDER


unpredictable until runtime because asynchronous
multiple threads run anytime, but order in 1 thread is ordered
"begin" comes before "end" etc


WHAT IS ASYNCHRONOUS


The thread executing the main() method does not wait for the results 
of each newly created thread before continuing


WHAT IS SYNCHRONOUS


the thread will wait until the results are available before 
returning control to enclosing program


RUN() VS START() - DIFFERENCE IN RESULT


1 calling run() on Thread or Runnable does not start a new thread
2 calling start() on Thread or Runnable does start a new thread
3 result is predictable with run() 
4 result is unpredictable until runtime with start()
// new Threads and unpredictable results
4:    (new ReadInventoryThread()).start();
5:    (new Thread(new PrintData())).start();
6:    (new ReadInventoryThread()).start();
// no new Threads and predictable results each time
4:    (new ReadInventoryThread()).run();
5:    (new Thread(new PrintData())).run();
6:    (new ReadInventoryThread()).run();


WHAT IS THE ORDER OF EXECUTION HERE


new PrintData().run();
(new Thread(new PrintData())).run();
(new ReadInventoryThread()).run();

the main() thread is the caller and will execute each task until its
done before moving on to the next


WHY IS USING WHILE() TO CHECK ON THREAD DATA BAD PRACTICE + WHAT 
METHOD WOULD BE BETTER


1 You are using CPU resources for no reason because you don't know 
when the thread wil reach your condition. 
2 Better to use Thread.sleep() to implement polling


WHAT DOES SLEEP() DO


1 pauzes the thread you put the sleep() in for n amount of ms
2 still no garuantees when your conditon is met but at least you are 
not killing your system for no reason


WHICH THREAD IS SLEEPING HERE


main()
	new Thread(Runnable lambda + checkResult)
	checkResult(while(false) Thread.sleep())

the main() Thread since sleep() is called on the main() thread


public class CheckResults {   
	private static int counter = 0;   
	public static void main(String[] args) throws InterruptedException {
		new Thread(() -> {         
			for(int i=0; i<500; i++) CheckResults.counter++;}).start();
			while(CheckResults.counter<100) {
				System.out.println("Not reached yet");
				Thread.sleep(1000); // 1 SECOND      
			}
			System.out.println("Reached!");}}


WHAT IS HAPPENING ABOVE


a new Thread is created to count to 500
when will this be done?

you dont know! could be forever since that thread needs to get time

so using while() without sleep() could kill your performance
which thread will be sleeping? 

main() since the counter thread is running separately until finished


WHICH EXCEPTION DO YOU NEED TO CHECK WITH SLEEP()


InterruptedException


WHICH INTERFACE DOES THE CONCURRENCY API INCLUDE FOR THREADS


1 ExecutorService
2 get instance of this interface
3 send service task to process
4 includes thread pooling and scheduling
5 should use even when making single thread tasks


HOW TO GET AN INSTANCE OF EXECUTORSERVICE


1 interface, so not with a constructor of course
2 Concurrency API includes Executors factory class


WHAT IS A FACTORY PATTERN AGAIN


1 The factory pattern is a 
2 creational pattern in which 
3 the underlying implementation details of the object creation 
4 are hidden from us.


WHAT IS THE EXECUTORSERVICE FACTORY PATTERN FOR SINGLE THREAD


ExecutorService service = Executors.newSingleThreadExecutor();


IS THE OVERALL ORDER GUARANTEED WITH SINGLETHREADEXECUTOR


no, because you still make a new single Thread next to main()
so you have 2 Threads, executing their tasks in order
but between them its not guaranteed


WHICH METHOD TO PERFORM ASYNCHRONOUS TASKS + WHAT IS THE ORDER


1 service.execute(Runnable or lambda); (void execute)
2 single thread so tasks are guaranteed to be ordered
3 but main() is still a seperate thread so end result still varies


IS A THREAD EXECUTOR DAEMON OR NOT AND CONSEQUENCE


1 user-defined thread so non-daemon
2 if not shutdown by programmer will run forever


HOW TO STOP USING YOUR THREAD EXECUTOR + CONSEQUENCES


1 call service.shutdown();
2 all new tasks are rejected
3 runnning tasks will be completed
4 calling isShutdown() will return true
5 calling isTerminated() will return false 
6 if all tasks are completed calling isTerminated() will return true


WHAT EXCEPTION IS THROWN DURING SHUTDOWN WITH NEW TASK


RejectedExecutionException


HOW TO CANCEL ALL RUNNING TASKS


1 use service.shutdownNow()
2 attempts to stop all tasks but might not succeed!


WHAT DOES SHUTDOWNNOW() PRODUCE


creates List<Runnable> of tasks that never started


DOES EXECUTORSERVICE IMPLEMENT AUTOCLOSEABLE


no, so you cant use it with try-with-resources and you have to 
shutdown the service manually in an explicit finally block


WHAT HAPPENS IF YOU FAIL TO SHUTDOWN A THREAD EXECUTOR


program hangs


EXECUTE() VS SUBMIT()


void		execute(Runnable)
Future 	submit(Runnable/Callable)
1 both take a Runnable lambda or instance
2 submit() can also take a Callable instance
3 execute() is fire and forget, no feedback on result
4 submit() returns a Future
5 both are asynchronous


WHERE DOES EXECUTE() COME FROM


Executor interface -> ExecutorService interface -> Executors class


EXECUTORSERVICE METHODS

	
1 void 						execute 	(Runnable command)
2 Future<?> 				submit	(Runnable task)
3 <T> Future<T> 			submit	(Callable<T> task)
4 <T> List<Future<T>>	invokeAll(Collection<? extends Callable<T>> 
								  			tasks) throws InterruptedException
5 <T> T 						invokeAny(Collection<? extends Callable<T>> 
								  			tasks) throws InterruptedException, 
											  				  ExecutionException

invokeAll() and invokeAny() also have overloaded versions that
take long timeout & TimeUnit unit)


WHAT DOES EXECUTIONEXCEPTION DO


if no tasks from invokeAny() finishes succesfully


WHAT ARE THE DIFFERENCES IN EXECUTION TIME AND FEEDBACK OF THESE 5


1 executes a Runnable task some time in the future
2 executes a Runnable task some time in the future and returns a 
	Future representing the task
3 executes a Callable task some time in the future and returns a 
	Future representing the pending results of the task
4 executes the given tasks and waits for all tasks to complete. 
	Returns a List of Future instances, in the same order they were 
	in the original collection
5 executes the given tasks and waits for at least one to complete. 
	Returns the task T (?) for a complete task and cancels any 
	unfinished tasks. Throws ExecutionException if none complete


WHAT IS FUTURE


1 interface type 
2 java.util.concurrent.Future<V>
3 returned by various API methods


FUTURE METHODS


1 boolean isDone()
2 boolean isCancelled()
3 boolean cancel(boolean mayInterruptIfRunning)
4 V 	  	 get() 
5 V 	  	 get(long timeout, TimeUnit unit)

get() = wait indefinitely on result
get(timeout) = wait on result for specified period of time


WHEN WILL ISDONE() RETURN TRUE


when task is completed, exception or cancelled


WHEN WILL ISCANCELLED() RETURN TRUE


true if cancelled before completed


WHAT DOES GET(TIMEOUT) DO AFTER TIME EXPIRED


throw checked TimeoutException when timeout is reached


ALTERNATIVE INTERFACE TO RUNNABLE


1 java.util.concurrent.Callable


WHAT ARE THE TWO MAIN DIFFERENCES BETWEEN RUNNABLE AND CALLABLE


call() returns a value and throws an exception


WHAT IS THE SAM OF CALLABLE


@FunctionalInterface 
public interface Callable<V> {
   V call() throws Exception;
}


AGAIN TO BE CLEAR THE SAM OF RUNNABLE AND CALLABLE


void run();
   V call() throws Exception;


WHEN CAN RUNNABLE AND CALLABLE BE INTERCHANGED


1 if lambda does not return a value
2 if lambda does not throw an exception
// submit + return Future<?> dan is het Runnable
// lambda mag dan geen parameters nemen of iets teruggeven
Future<?> result = service.submit(() -> {CheckResults.counter++;});

// submit + return Future<T> dan is het Callable
// lambda mag geen parameters hebben maar wel iets teruggeven
Future<Integer> result = service.submit(() -> 30 + 11);


RETURN VALUE OF FUTURE<V> WHEN USING GET() ON RUNNABLE AND CALLABLE


void since Runnable.run() is void so always null on get()
matching generic type on Callable but could also be null


WHAT IS AN AMBIGUOUS LAMBDA EXPRESSION


when a lambda cant resolve to a single FI


WHAT HAPPENS WITH ALE


compiler error


HOW TO FIX


explicit cast of the parameter to the FI you want to use


EXAMPLE


public class AmbiguousLambdaSample {   
	public static void useCallable(Callable<Integer> expression) {}
	public static void useSupplier(Supplier<Integer> expression) {}
	public static void use(Callable<Integer> expression) {}   
	public static void use(Supplier<Integer> expression) {}   
	public static void main(String[] args) {      
		useCallable(() -> {throw new IOException();});
		useSupplier(() -> {throw new IOException();});
		use 		  (() -> {throw new IOException();});
}}

IS THIS OK: useCallable(() -> {throw new IOException();});

yes, a callable returns on object Future<V> and can throw exception

IS THIS OK: useSupplier(() -> {throw new IOException();});

no! does not compile, Supplier returns an Object but can not throw an
exception

IS THIS OK: use(() -> {throw new IOException();});

no, ambiguous lambda expression

why?

use() can refer to the supplier or the callable version of use()
both return an object

but supplier cant throw an exception, shouldnt it just pick callable?

well, the compiler does not look at the body of the lambda in this 
case, so it doesnt know an exception is being thrown. You need to fix
this ambiguouity regardless

compiler sees no parameter and a return value
it then tries to pick a FI, but it sees 2 compatible FIs, so error

then what is the fix?

cast to the one you want that can throw an exception

use((Callable<Integer>)() -> { throw new IOException("");});


CHECKED EXCEPTIONS IN CALLABLE AND RUNNABLE


service.submit(() -> {Thread.sleep(1000); return null;});
service.submit(() -> {Thread.sleep(1000);});


which method compiles?

only the first will compile

why?

first method is Callable since it has a return object
second method is Runnable since it does not have a return object
only Callable supports checked exception

why is that important?

Thread.sleep() throws InterruptedException which is checked so
handle or declare


HOW TO PROPERLY WAIT FOR ALL TASKS TO FINISH WITH AN EXECUTORSERVICE


First call service.shutdown();
Then  call service.awaitTermination(1, TimeUNit.MINUTES);
Now you can call servive.isTerminated() to see result


WHAT DOES AWAITTERMINATION DO


1 available to all thread executors
2 waits specified time for all tasks to complete


WHEN WILL AWAITTERMINATION RETURN SOONER


3 returns sooner if all tasks are complete or InterruptedException


WHAT HAPPENS IF YOU CALL AWAITTERMINATION() BEFORE SHUTDOWN()


1 within same thread
2 wait full duration of timeout specified


INVOKEALL() AND INVOKEANY() SYNCHRONOUS OR NOT AND WHAT DOES IT MEAN


1 synchronous unlike the other 3 executor methods
2 these methods wait until results are available before returning 
  control to the enclosing program
3 take a collection of tasks


INVOKEALL() AND INVOKEANY() DIFFERENCE AND RETURN VALUE


1 invokeAll() executes all tasks in collection in order 
2 returns List<Future<String>> of all tasks in order
3 invokeAny() executes collection of tasks and returns the result of 
	one of the tasks that completes succesfully and cancels 
	unfinished tasks


WHAT DOES FUTURE.ISDONE() RETURN


1 future.isDone() returns true for all tasks returned in the List 
  but task could have thrown an exception or be cancelled


WHICH TASK DOES INVOKEANY() RETURN


usually first but is not guaranteed, any task can be returned


HOW LONG DO INVOKEALL AND INVOKEANY WAIT


1 in both cases JVM waits indefinitely until all tasks / one task is 
	returned


WHAT IS THE OVERLOADED VERSION OF INVOKEALL INVOKEANY


1 one that takes a timeout value and TimeUnit value
invokeAll(Collection<? extends Callable> list, 1, TimeUnit.X);
invokeAny(Collection<? extends Callable> list, 1, TimeUnit.X);


WITH WHAT CAN YOU SCHEDULE A TASK


With ScheduledExecutorService, which is a subinterface of 
ExecutorService


HOW DO YOU USE SCHEDULEDEXECUTORSERVICE


ScheduledExecutorService service = 
Executors.newSingleThreadScheduledExecutor();


CAN YOU USE EXECUTORSERVICE AS VARIABLE


yes, but then you need to (cast) constantly to use scheduled methods


SCHEDULEDEXECUTORSERVICE METHODS


1 schedule 		   		(Callable<V> callable, 
				 		 		 long delay, 
						 		 TimeUnit unit)
2 schedule 		   		(Runnable command, 
						 		 long delay, 
						 		 TimeUnit unit)
3 scheduleAtFixedRate  	(Runnable command, 
						 		 long initialDelay, 
						 		 long period, 
						 		 TimeUnit unit)
4 scheduleWithFixedDelay(Runnable command, 
								 long initialDelay, 
								 long delay, 
						 		 TimeUnit unit)


RETURN TYPES FUTURE VS SCHEDULEDFUTURE INSTANCE


identical but scheduled includes getDelay() for remaining delay


DIFFERENCE BETWEEN SCHEDULEATFIXEDRATE AND SCHEDULEWITHFIXEDDELAY


scheduleAtFixedRate creates a new task after delay regardless if 
previous task completed or not
scheduleWithFixedDelay only starts task after delay AFTER the 
previous task completed


WHY NO CALLABLE VERSIONS FOR FIXEDRATE AND FIXEDDELAY


they are meant to run infinitely so you would get infinite Futures


WHAT IS A THREAD POOL


1 A group of pre‐instantiated reusable threads 
2 that are available to perform a set of arbitrary tasks.


FIVE FACTORYMETHODS OF EXECUTORS.


         ExecutorService  es = null;
ScheduledExecutorService ses = null; 

1  es = Executors.newSingleThreadExecutor();
2  es = Executors.newCachedThreadPool();
3  es = Executors.newFixedThreadPool(int);
4 ses = Executors.newSingleThreadScheduledExecutor();
5 ses = Executors.newScheduledThreadPool(int);


DIFFERENCE BETWEEN A SINGLE‐THREAD AND A POOLED‐THREAD


single thread waits on previous task but pooled thread can execute 
concurrently and queue if no more threads


NEWCACHEDTHREADPOOL()


Creates a thread pool that creates new threads as needed but will 
reuse previously constructed threads when they are available


NEWFIXEDTHREADPOOL(INT)


takes an int and creates int amount of threads to use and reuse


NEWSCHEDULEDTHREADPOOL(INT)


= newCachedThreadPool but scheduled
ScheduledExecutorService service = 
	Executors.newScheduledThreadPool(10);
service.scheduleAtFixedRate(command,3,1,TimeUnit.MINUTE);


WHAT IS THREAD-SAFETY


The property of an object that guarantees safe execution by multiple 
threads at the same time. 
1 thread A reads a variable of the object 
2 thread B reads a variable of the object 
3 thread A writes a new value to variable of the object 
4 thread B writes a new value to variable of the object
value of A is lost


WHAT IS RACE CONDITION AND WHAT DOES IT LEAD TO


The unexpected result of two tasks executing at the same time and 
not taking into account each others results.
For the exam, you should understand that race conditions lead to 
invalid data if they are not properly handled. Even the solution 
where both participants fail to proceed is preferable to one in 
which invalid data is permitted to enter the system.


HOW CAN YOU MAKE ++ THREAD-SAFE


With the Atomic package
Atomic = the property of an operation to be carried out as a single 
unit of execution without any interference by another thread.
example:
1 thread A reads a variable of the object 
2 thread B wants to read a variable of the object but is not allowed
3 thread A writes a new value to variable of the object 
4 thread B is now allowed to read the value of the object
no value is lost


WHAT HAPPENS IF A THREAD WANTS TO ACCESS AN ATOMIC VARIABLE IN USE


it has to wait until the atomic operation is done


ATOMIC CLASSES


BIALARA

AtomicBoolean
AtomicInteger
AtomicIntegerArray
AtomicLong
AtomicLongArray
AtomicReference
AtomicReferenceArray

these may be updated atomically

what is AtomicReference

its just the Object version that holds generic object references


ATOMIC METHODS


get()		   			return value
set()		   			assign value
getAndSet()	   		Atomically get old value and set new value
incrementAndGet() 	atomically increment current value by 1 and return new value
decrementAndGet() 	atomically decrement current value by 1 and return new value
getAndIncrement() 	return old value and atomically increment current value by 1
getAndDecrement() 	return old value and atomically decrement current value by 1

int x = ai.addAndGet(1); 

this method exists and adds the int to the value and returns it

Atomic classes are not wrapper classes so they will no do boxing.
If you do AtomicInteger + 1 it will not compile


DIFFERENCE IN OUTPUT NORMAL VS ATOMIC CLASSES


output for normal classes is unordered and may have dupes or misses
output for atomic classes is unordered but does not have any dupes


HOW TO SYNCHRONIZE ACCESS


With a Lock aka monitor


WHAT IS A MONITOR


A structure that supports mutual exclusion, which is the property 
that at most one thread is executing a particular segment of code at 
a given time.
i.e. you appoint one java object as monitor that makes sure no two
threads are operating at the same time


WHAT CAN BE USED AS MONITOR AND HOW


Every java object with the synchronized keyword


WHAT IS A SYNCHRONIZED BLOCK AND HOW DOES IT WORK


SheepManager manager = new SheepManager();
synchronized(manager) { 
	// Work to be completed by one thread at a time
}
only one thread may be active in the block at any time and acquires 
the lock for the monitor
other threads are prevented from entering


DO YOU NEED TO SYNCHRONIZE ON ONE OR MORE OBJECTS TO PREDICT RESULTS


on ONE and the SAME object


EXACTLY WHAT DO YOU NEED TO SYNCHRONIZE TO ORDER RESULTS


You need to synchronize the execution of threads and not creation of 
threads
If you sync creation of threads, one thread is made at a time but 
they still all execute concurrently when possible


EXAMPLE OF INCORRECT AND CORRECT SYNCHRONIZATION


// create 20 threads to be used by the service
service = Executors.newFixedThreadPool(20);

// synchronize only the CREATION of the 20 threads for the service
// but leave incrementAndReport() unsynchronized
for(int i = 0; i < 10; i++) {
	synchronized(manager) {
		service.submit(() -> manager.incrementAndReport());
	}
}

// dont sync the CREATION of threads, 
   but the EXECUTION of the threads instead
private void incrementAndReport() {
	synchronized(this) {         
		System.out.print((++sheepCount)+" ");
	}   
}


//  it doesnt matter on which object you synchronize to complete 
	your tasks in order 1 by 1, as long as you sync on ONE SAME object
private final Object herd = new Object();
private void incrementAndReport() {
	synchronized(herd) {      
		System.out.print((++sheepCount)+" ");
	}
}


IS A SYNCHRONIZED BLOCK WITH ATOMIC CLASSES USEFUL


no, the synchronized block already allows only 1 thread at a time
to work on the object


TWO WAYS TO USE SYNCHRONIZED


1 on object in method
2 on method itself
private void incrementAndReport() {
	synchronized(this) {      
		System.out.print((++sheepCount)+" ");
	}
}
private synchronized void incrementAndReport() {   			
	System.out.print((++sheepCount)+" ");
}


WHAT OBJECT IS USED AS THE MONITOR WHEN WE SYNCHRONIZE ON A STATIC 
METHOD


the class object
public static void printDaysWork() {
	synchronized(SheepManager.class) {      
		System.out.print("Finished work");
	}
}
public static synchronized void printDaysWork() {   
	System.out.print("Finished work");
}


WHAT IS A MEMORY CONSISTENCY ERROR


Occurs when two threads have inconsistent views of what should be 
the same data.


WHAT CAN HAPPEN IF YOU REMOVE A KEY FROM HASHMAP USING ITERATOR


ConcurrentModificationException since the iterator on the next loop 
does not have the new data
Map<String, Integer> foodData = new HashMap<String, Integer>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet()) foodData.remove(key);


WHEN CAN YOU GET A CONCURRENTMODIFICATIONEXCEPTION


When you iterate over a collection while adding to or removing from 
it. Even for single threads. Prevent this with concurrent classes.


WHAT DO THE CONCURRENT CLASSES DO


The concurrent classes were created to help avoid common issues in 
which multiple threads are adding and removing objects from the same 
collections. At any given instance, all threads should have the same 
consistent view of the structure of the collection.


WHEN SHOULD YOU USE A CONCURRENT CLASS AND WHEN NOT


1 Anytime that you are going to have multiple threads 
2 modify a collections object 
3 outside a synchronized block or method, 
4 even if you don't expect a concurrency problem.


WHEN DO YOU NOT NEED A CONCURRENT CLASS IN THE ABOVE EXAMPLE


You dont need concurrent classes for immutable objects


CONCURRENT COLLECTION CLASSES


Concurrent HashMap

Concurrent SkipListMap
Concurrent SkipListSet

CopyOnWriteArray List
CopyOnWriteArray Set

Concurrent LinkedDeque
Concurrent LinkedQueue
LinkedBlockingDeque
LinkedBlockingQueue


WHICH COLLECTIONS ARE ORDERED 


all but ConcurrentHashMap and CopyOnWriteArraySet
maps and sets that are not sorted use hashCode() to find elements
and hashCode() is not ordered, it does not have an index to work with


WHICH COLLECTIONS ARE SORTED


only Tree-like collections, which are called SkipList in concurrent
ConcurrentSkipListMap and ConcurrentSkipListSet


WHICH COLLECTIONS ARE BLOCKING


only those with blocking in the name
LinkedBlockingDeque and LinkedBlockingQueue


WHAT ARE THE COPYONWRITE CLASSES


1 copy all elements to new underlying structure
2 anytime an element is added, modified or removed
3 modified means object reference is changed and not the actual 
	object


HOW DOES AN ITERATOR WORK WITH COPYONWRITECLASSES


it only iterates over the original values and not over changes made 
while iterating
new CopyOnWriteArrayList<>(List.of(4,3,42));
for(Integer n: favNumbers) {   
	System.out.print(n + " ");
	favNumbers.add(9);
}
4 3 42  -> 4 9 3 9 42 9
size is now 6! does not hang since it only iterates over original 
values


WHEN SHOULD YOU USE COPYONWRITECLASSES


they require lots of resources so use them in multithreaded 
environments where you read far more commonly than you write


ARE THE COPYONWRITE CLASSES IMMUTABLE


no, they behave like immutable classes, but the reference to the 
original object stays the same


WHAT DOES LINKEDBLOCKINGQUEUE DO THAT QUEUE DOES NOT


Includes methods that wait a specific amount of time to complete an 
operation.


BLOCKINGQUEUE SPECIFIC METHODS ON TOP OF QUEUE METHODS


1 offer(E e, long timeout, TimeUnit unit) throws InterruptedException
2 poll (     long timeout, TimeUnit unit) throws InterruptedException

1 Adds an item to the queue waiting the specified time and 
  returning false if the time elapses before space is available.
2 Retrieves and removes an item from the queue, 
  waiting the specified time and 
  returning null if the time elapses before the item is available.


EXAMPLE


try {   
	BlockingQueue<Integer> blockingQueue = 
		new LinkedBlockingQueue<Integer>();   
	blockingQueue.offer(39);    				  		
	blockingQueue.offer(3, 4, TimeUnit.SECONDS);
	System.out.println(blockingQueue.poll());     
	System.out.println(blockingQueue.poll(10,TimeUnit.MILLISECONDS));
} 
catch (InterruptedException e) {
	// Handle interruption
}

This code snippet prints the following:
39
3


BLOCKINGDEQUE SPECIFIC METHODS ON TOP OF QUEUE METHODS


1 offerFirst(E e, long timeout, TimeUnit unit) throws 
										InterruptedException
2 offerLast (E e, long timeout, TimeUnit unit) throws 
										InterruptedException
3 pollFirst (     long timeout, TimeUnit unit) throws
										InterruptedException
4 pollLast  (     long timeout, TimeUnit unit) throws
										InterruptedException

1 Adds an item to the FRONT of the queue, 
  waiting the specified time and 
  returning false if the time elapses before space is available.
2 Adds an item to the TAIL of the queue, 
  waiting the specified time and 
  returning false if the time elapses before space is available.
3 Retrieves and removes an item from FRONT of the queue, 
  waiting the specified time and 
  returning null if the time elapses before the item is available.
4 Retrieves and removes an item from TAIL of the queue, 
  waiting the specified time and 
  returning null if the time elapses before the item is available.


EXAMPLE

try {   
	BlockingDeque<Integer> blockingDeque = newLinkedBlockingDeque<>();   
	blockingDeque.offer(91);   
	blockingDeque.offerFirst(5, 2, TimeUnit.MINUTES); 
	blockingDeque.offerLast(47, 100, TimeUnit.MICROSECONDS);   
	blockingDeque.offer(3, 4, TimeUnit.SECONDS);   
	System.out.println(blockingDeque.poll());   
	System.out.println(blockingDeque.poll(950, TimeUnit.MILLISECONDS));
	System.out.println(blockingDeque.pollFirst(200, TimeUnit.NANOS));
	System.out.println(blockingDeque.pollLast(1, TimeUnit.SECONDS));
} catch (InterruptedException e) {   
	// Handle interruption
}

proces-flow:
offer 91 immediately
offer  5 to front of the queue waiting 2 minutes for completion
offer 47 to tail  of the queue waiting 100 micros for completion
offer  3 to tail  of the queue waiting 4 seconds
           <------------------------
queue is : front [5, 91, 47, 3] tail
output:
poll 		 //5
poll 	 	 //91
pollFirst //47
pollLast  //3


WHAT ARE SYNCHRONIZED COLLECTION METHODS AND WHEN SHOULD YOU USE THEM


1 If on creation you know you need sync: use concurrent collections
2 If you get a regular collection you need to access over multiple 
	threads: wrap the collection in the synchronized collection method
3 static method


WHAT IS A DRAWBACK OF SYNCHRONIZED COLLECTION METHODS VS 
					  CONCURRENT COLLECTIONS


1 you still get ConcurrentModificationException on collections you 
	wrap in synced methods when you iterate over them while modifying 
	them
2 however, the synced methods return objects that are safe from 
	memory consistency errors and can be used among multiple threads


SYNCHRONIZED COLLECTION METHODS - IN WHICH CLASS ARE THEY


Collections class


SYNCHRONIZED COLLECTION METHODS - WHAT DO THEY RETURN


same type as inputted collection type


SYNCHRONIZED COLLECTION METHODS - WHICH ONES ARE THERE


Collections.synchronizedCollection(Collection<T> c)
Collections.synchronizedList(List<T> list)
Collections.synchronizedMap(Map<K,V> m)
Collections.synchronizedNavigableMap(NavigableMap<K,V> m)
Collections.synchronizedNavigableSet(NavigableSet<T> s)
Collections.synchronizedSet(Set<T> s)
Collections.synchronizedSortedMap(SortedMap<K,V> m)
Collections.synchronizedSortedSet(SortedSet<T> s)

public static <T> Collection<T> synchronizedCollection(
	Collection<T> c) {
        return new SynchronizedCollection<>(c);
    }
SynchronizedCollection = static class in Collections.class and 
implements Collection interface


SYNCHRONIZED VS CONCURRENT EXAMPLE


Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);

Map<String,Object> synchronizedFoodData = 
 	Collections.synchronizedMap(foodData);

for(String key: synFoodData.keySet()) {
	synFoodData.remove(key);
}

this results in a ConcurrentModificationException because it is only
synchronized and not a true concurrent collection, unlike 
ConcurrentHashMap


WHAT ARE SERIAL AND PARALLEL STREAMS + BENEFIT


Serial: results are ordered and only one entry processed at a time.
Parallel: use multiple threads to process results concurrently.
Benefit of parallel stream is higher performance


HOW TO CREATE A PARALLEL STREAM


1 call parallel() on an existing stream
2 call parallelStream() on a Collection object


WARNING ON PARALLEL()


1 is an intermediate operation 
2 operates on the original stream
3 terminal on parallel stream also closes original stream


HOW TO CHECK IF A STREAM IS PARALLEL + EXAMPLES


isParallel()
some operations preserve parallel attribute, for example:
1 The Stream.concat(Stream s1, Stream s2) is parallel if 
	either s1 or s2 is parallel. 
2 On the other hand, flatMap() creates a new stream that is not 
	parallel by default, regardless of whether the underlying 
	elements were parallel.


WHAT IS PARALLEL DECOMPOSITION


1 The process of taking a task
2 breaking it into smaller pieces that can be performed concurrently
3 and then reassembling the results.


STREAM VS PARALLELSTREAM EXAMPLE


private static int doWork(int input) {   
	try {Thread.sleep(5000);   
} catch (InterruptedException e) {}   return input;}

long start = System.currentTimeMillis();
List.of(1,2,3,4,5)
	.stream()
	.map(w -> doWork(w))   
	.forEach(s -> System.out.print(s + " "));
System.out.println();
var timeTaken = (System.currentTimeMillis()-start)/1000;
System.out.println("Time: "+timeTaken+" seconds");


WHAT IS THE OUTPUT NOW


1 2 3 4 5 
Time: 25 seconds
because its a serial stream using 1 cpu in order


NOW CHANGE .STREAM() INTO .PARALLELSTREAM() - WHAT IS THE OUTPUT


4 5 2 3 1 
Time: 5 seconds
because order is not guaranteed but with 5 cpus its fast


FOREACH() + ALTERNATIVE METHOD WITH PREVIOUS EXAMPLE


forEach() uses multiple cpus but does not order it
forEachOrdered() does the same but forces order at the cost of some 
performance and stream becomes serial
example:
	.forEachOrdered(s -> System.out.print(s + " "));
1 2 3 4 5 
Time: 5 seconds
now ordered and still able to do it in 5 seconds


WHAT ARE PARALLEL REDUCTIONS


reduction operations on parallel streams


WHAT ARE DIFFERENCES BETWEEN PARALLEL AND SERIAL REDUCTIONS


results of parallel reduction are not the same as serial streams
serial is higher chance of returning 1st result but not guaranteed
findAny() can return any value of the stream depending which thread 
completes first


WHICH TYPE OF STREAM OPERATIONS ARE SLOWER WITH PARALLEL STREAMS


operations that rely on order such as 


findFirst() 
limit() 
skip()
This is a result of a parallel processing task being forced 
to coordinate all of its threads in a synchronized‐like fashion.


WHEN WILL SERIAL AND PARALLEL STREAM RETURN THE SAME RESULT


with ordered operations on ordered streams such as 
skip()
limit()
findFirst()


DIFFERENCE SERIAL AND PARALLEL STREAM IN REDUCING VALUES


In a serial stream, wolf is built one character at a time. 
In a parallel stream, the intermediate values wo and lf are created 
and then combined.


WHAT IS THE CONDITION TO MAKE SURE STREAM API ORDERS REDUCTIONS


for all elements in the stream, identity + u = u
accumulator and combiner must work the same in any order

make sure the accumulator and combiner work regardless of order of 
calling
this means that the order in which the accumulator and combiner work
does not affect the result
adding numbers can be done in any order and produce same result
substracting numbers can not be done in any order for same result


EXAMPLE OF A PROBLEMATIC ACCUMULATOR

coll.parallelStream()
	.reduce(0, (a,b) -> (a - b)));  // PROBLEMATIC ACCUMULATOR
			It may output ‐21, 3, or some other value.
	.reduce("X", String::concat));  // XwXoXlXf
coll.stream()
	.reduce("X", String::concat));  // Xwolf
identity needs to be a proper identity and get called 1 time with
serial stream but many times with parallelstream


SOLUTION TO THESE PROBLEMATIC REDUCE OPERATIONS


use a combiner
you dont need a combiner if the intermediate types are the same
but you can get unpredictable results with a bad accumulator


WHICH OVERLOADED METHOD IS BEST TO USE WITH COLLECT()


the one with supplier, accumulator and combiner


WHICH COLLECTION TYPE TO USE WHEN COLLECTING PARALLEL STREAMS


the concurrent versions to prevent ConcurrentModificationException
Stream<String> stream = Stream.of("w", "o", "l","f").parallel();
SortedSet<String> set = stream.collect(
	ConcurrentSkipListSet::new,
	Set::add,
	Set::addAll);
System.out.println(set);  // [f, l, o, w]


PARALLEL REDUCTION ON A COLLECTOR - SPECIAL METHOD IN COLLECTOR


Collector.characteristics();


WHAT DOES IT RETURN


return set of Collector.Characteristics attributes


WHAT HAPPENS IF SOME CHARACTERISTICS ARE NOT TRUE


stream will execute in single-threaded fashion even with a parallel 
stream


WHAT THE REQUIREMENTS THEN FOR PARALLEL REDUCTION TO TAKE PLACE


1 stream is parallel
2 parameter of collect() has Collector.Characteristics.CONCURRENT
3 stream is unordered or collector has Characteristics.UNORDERED


EXAMPLE OF COLLECT() NOT USING PARALLEL REDUCTION


stream.collect(Collectors.toSet());  // Not a parallel reduction
Collectors.toSet() does have the UNORDERED characteristic, but it 
does not have the CONCURRENT characteristic.


WHAT METHODS IN COLLECTORS PRODUCE PARALLEL REDUCTION INSTANCES


1 toConcurrentMap()
2 groupingByConcurrent()
3 these are static methods
4 both are UNORDERED AND CONCURRENT


EXAMPLE


Stream<String> ohMy =Stream.of("lions","tigers","bears").parallel();
ConcurrentMap<Integer, String> map = ohMy.collect(
	Collectors.toConcurrentMap(
		String::length,
		k -> k,
		(s1, s2) -> s1 + "," + s2));
System.out.println(map);             
	// {5=lions,bears, 6=tigers}
System.out.println(map.getClass());
	//java.util.concurrent.ConcurrentHashMap
	The particular class is not guaranteed; it will just be a class 
	that implements the interface ConcurrentMap.


GROUPINGBYCONCURRENT EXAMPLE REWRITE


var ohMy = Stream.of("lions","tigers","bears").parallel();
ConcurrentMap<Integer, List<String>> map = ohMy.collect(
	Collectors.groupingByConcurrent(
		String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


WHAT ARE INDEPENDENT OPERATIONS


parallel operations that dont rely on each other
Arrays.asList("jackal","kangaroo","lemur")
	.parallelStream()
	.map(s -> s.toUpperCase())
	.forEach(System.out::println);
KANGAROO
LEMUR
JACKAL
order is not guaranteed but it works fine
.forEachOrdered() would still order them naturally


WHAT ARE SIDE EFFECTS


when you use a parallelstream that produces unwanted behavior


WHEN DO THESE USUALLY OCCUR


when you embed operations that produce a result before terminal

Arrays.asList("jackal","kangaroo","lemur")     
	.parallelStream() 
	.map(s -> {System.out.println(s); return s.toUpperCase();})
	.forEach(System.out::println);
kangaroo  
KANGAROO  
lemur  
jackal  
JACKAL  
LEMUR


EXAM NOTE


Remember that parallel streams can process results independently, 
although the order of the results can not be determined ahead of time


WHAT ARE STATEFUL / STATELESS LAMBDA EXPRESSIONS


A lambda expression where the result depends on any state that might 
change during execution of the pipeline.
Stateless does not depend on state


BAD EXAMPLE OF STATEFUL


public List<Integer> addValues(IntStream source) {   
	 List<Integer> data = Collections.synchronizedList(
		newArrayList<Integer>());   
	source.filter(s -> s % 2 == 0)
	.forEach(i -> { data.add(i); });  // STATEFUL: DON'T DO THIS!   
	return data;
}
var list = addValues(IntStream.range(1, 11));
System.out.println(list);
Then, the output would be as follows: [2, 4, 6, 8, 10]

But what if someone else wrote an implementation that passed our 
method a parallel stream?
var list = addValues(IntStream.range(1, 11).parallel());
System.out.println(list);
With a parallel stream, the order of the output becomes random.
[6, 8, 10, 2, 4]
The problem is that our lambda expression is stateful and modifies a 
list that is outside our stream. 
forEachOrdered() would produce order but lose parallel stuff


ANOTHER BAD EXAMPLE


List<Integer> data = 
	Collections.synchronizedList(new ArrayList<>());  
Arrays.asList(1,2,3,4,5,6)
	.parallelStream() 
	.map(i -> {data.add(i); return i;})
	.forEachOrdered(i -> System.out.print(i+" "));

System.out.println();  
for(Integer e: data) {
	System.out.print(e+" ");  
}


WHAT DOES THIS PRINT


the list is created with 1,2,3,4,5,6
all entries are processed in parallel and added to 'data'
the terminal operation prints the stream elements in order
[1,2,3,4,5,6]


WHAT ABOUT THE LIST PRINT PART


well, the elements are added to the list in parallel, meaning
order is no longer guaranteed
the list could print any order!
[2,4,3,5,6,1] or whatever

the problem is, you used a stateful object outside the parallel
stream which is no longer ordered


GOOD EXAMPLE


public static List<Integer> addValues(IntStream source) {   
	return source
	.filter(s -> s % 2 == 0)      
	.boxed()      
	.collect(Collectors.toList());
}
This implementation removes the stateful operation and relies on 
the collector to assemble the elements.


WHAT IS GOOD PRACTICE 


Write the code to allow parallel processing and let the JVM handle it.


EXAMPLE USING CYCLICBARRIER AND SHOW OUTPUT


public void performTask() {
	removeLions();
	cleanPen();
	addLions();
}
try {         
	service = Executors.newFixedThreadPool(4);         
	var manager = new LionPenManager();         
	for (int i = 0; i < 4; i++) service.submit(() -> 
										manager.performTask());
} finally {         
	if (service != null) service.shutdown();      
}


IS THE RESULT OF THE EXAMPLE ORDERED OR NOT AND WHY


within one thread the result is ordered but between the four threads
the results are not ordered at all


HOW TO ORDER RESULTS WITH CYCLICBARRIER CLASS


performTask(CyclicBarrier c1, CyclicBarrier c2) {
	removeLions();
	c1.await();
	cleanPen();
	c2.await();
	addLions();
}
try {         
	service = Executors.newFixedThreadPool(4);
	Cyclicbarrier c1 = new CyclicBarrier(4);         
	Cyclicbarrier c2 = new CyclicBarrier(4, () -> print("cleaned!"));
	var manager = new LionPenManager();         
	for (int i = 0; i < 4; i++) service.submit(() -> 
										manager.performTask(c1,c2));
} finally {         
	if (service != null) service.shutdown();      
}

> new CyclicBarrier(4, () -> print("cleaned!")) only printed once!!


WHAT HAPPENS IF YOU USE LESS THREADS IN A POOL THAN BARRIERS


code hangs because the barrier would never be reached


IS A CYCLICBARRIER REUSABLE


yes, barrier limit of 5 and 15 threads means barrier is used 3 times


WHAT IS RECURSION


a method/task calling itself


WHAT DOES THE FORK/JOIN FRAMEWORK DO


split a task into multiple other tasks to complete complicated tasks


WHAT IS THE BASE CASE


a non-recursive method used to terminate the recursive path


WHAT IS A RECURSIVE CASE


a recursive method that may call itself n times to solve a problem


EXAMPLE


public static int factorial(int n)  {   
	if(n<=1) return 1;   
	else return n * factorial(n-1);
}

what is the base case here

1

what is the recursive case

any integer greater than 1

you need to always be able to reach the base case!


THREE STEPS TO IMPLEMENT THE FORK/JOIN FRAMEWORK


1 create a  ForkJoinTask
2 create a  ForkJoinPool
3 start the ForkJoinTask


WHAT DOES STEP 1 REPRESENT


most complex, define the recursive process


WHICH TWO CLASSES IMPLEMENT THE FORKJOINTASK INTERFACE


1 RecursiveAction
2 RecursiveTask


WHAT TYPE IS RECURSIVEACTION AND WHAT METHOD DOES IT HAVE


abstract class that has the void compute(); method


WHAT TYPE IS RECURSIVETASK AND WHAT METHOD DOES IT HAVE


abstract generic class that has the <T> compute(); method


THESE TWO LOOK LIKE WHAT OTHER TWO THINGS YOU KNOW


Runnable and Callable


WHAT IS THE MAIN TAKEAWAY FROM FORKJOIN


you start a single task that may create additional tasks

each started task can finish independently of each other


CREATE A FORKJOINTASK REQUIRES 


extending RecursiveAction/Task and overriding compute()

public class WeighAnimalTask extends RecursiveAction  {
	 protected void compute() {
		if(base case to be met) {
			//dostuff
		} else {
			//if base case is not met make more tasks
			//define the recursive tasks
			//performed by calling the class itself again!
		}
	}
}

ForkJoinTask<?> task = new WeighAnimalAction(
											 weights,0,weights.length); 


CREATE A FORKJOINPOOL AND RUN IT


easy
ForkJoinPool pool = new ForkJoinPool();       
pool.invoke(task);


WILL INVOKE(FORKJOINTASK) EXECUTE IMMEDIATELY


you dont know, depends on available threads etc 


DOES INVOKE() RETURN SOMETHING


no void


WHY CHOOSE ACTION OVER TASK


if you dont want anything back, choose action
but if you want something back, like a total value, use task

protected Double compute() {
	if(base case to be met) {
		//dostuff
		//return Double
	} else {
		//if base case is not met make more tasks
		//RecursiveTask<Double> otherTask = task stuff
		//otherTask.fork();
		//return new Task.compute() + otherTask.join();
	}
}


WHAT DO FORK() AND JOIN() DO


fork() instructs the forkjoin framework to complete task in a 
separate thread

join() causes the current thread to wait for the results


EXAME TRICK THINGY WHEN TO CALL FORK() AND JOIN()


make sure that fork() is called

before the current thread begins a subtask

and that join() is called

after it finishes retrieving the results

or else you cant use

parallel operations

RecursiveTask<Double> otherTask = 
	new WeighAnimalTask(weights,start,middle);         
Double otherResult = otherTask.fork().join();         
return new WeighAnimalTask(weights,middle,end).compute() + otherResult;

otherTask.fork() = start a new thread!
otherTask.fork().join() = start a new thread but wait until its done
before you start new WeighAnimalTask(weights,middle,end).compute()


OTHER FORKJOIN EXAM PROBLEMS YOU CAN ENCOUNTER


if forkjoin is used, the class with the task should extend

RecursiveAction or Task

if RecusiveAction is used, the class must

override protected void compute() no args!

if RecusiveTask is used, the class must

override protected <T> compute() no args!

the invokeAll() method parameters are

2 instances of fork/join class and returns 

nothing

fork() method 

causes a new thread to be submitted to the pool like submit()

join() method

called after fork() causes current thread to wait on results

unlike fork(), calling compute() within a compute() method causes

the task to wait for the results of the subtask

when should fork() be called

before current thread performs a compute() operation with join()
called to read the results afterwards

compute() takes no argument so what is used to pass instructions

the constructor of the class
RecursiveTask<Double> otherTask = 
	new WeighAnimalTask(weights,start,middle);            
otherTask.fork(); 
return new WeighAnimalTask(weights,middle,end).compute() + 
otherTask.join();

TO PROPERLY USE FORK JOIN PARALLEL

1 call fork() first to start a new thread
	//otherTask.fork();
2 call compute()
	//new ClassThatExtendsRecursive().compute();
3 call join() last to read results
	//otherTask.join();

if you use invokeAll() you dont want a value back and use Action
if you want a value back, use fork and join and Task


WHAT IS LIVENESS AND LIST 3 ISSUES


The ability of an application to be able to execute in a timelymanner.
Liveness problems are those in which the application becomes 
unresponsive. 
1 deadlock
2 starvation
3 livelock


DEADLOCK


two or more threads block each other forever waiting on the other
you can still have output but then the program hangs
example:
you need both food and water to eat a meal
thread A has water and thread B has food
they cant get the other resource and wait indefinitely = deadlock


STARVATION


A single active thread can never complete because other threads keep 
taking the resource.


LIVELOCK


Conceptually starvation but with two or more threads which are still 
active and trying to get their task complete but can never finish 
because they block each other in various areas.
AKA failed deadlock recovery. Understand the deadlock, release lock 
and go to a different lock, but keep blocking each other.
example:
like above but now they both release their resource and claim the 
other resource
they still cant finish the meal, but they keep switching locks and
still output stuff = livelock


WHAT IS RACE CONDITION AND WHAT DOES IT LEAD TO


The unexpected result of two tasks executing at the same time and 
not taking into account each others results.
Two tasks, which should have been executed sequentially, complete
at the same time.
For the exam, you should understand that race conditions lead to 
invalid data if they are not properly handled. Even the solution 
where both participants fail to proceed is preferable to one in 
which invalid data is permitted to enter the system.


CHAPTER QUESTIONS


>
ExecutorService service = Executors.newSingleThreadScheduledExecutor();
service.scheduleWithFixedDelay(() -> {      
		System.out.println("Open Zoo");      
		return null;   	
	}, 0, 1, TimeUnit.MINUTES);
Future<?> result = service.submit(()->System.out.println("Wake Staff"));
System.out.println(result.get());

Problems?

newSingleThreadScheduledExecutor creates a Ses but you assign to Es

ExecutorService.scheduleWithFixedDelay() does not exist so no compile

also

scheduleWithFixedDelay() uses only Runnable which does not return 
anything, so return null also does not compile

second-last line is fine, submit has a runnable version to not return
anything to the Future<?>


>
IntStream.iterate(1, i -> 1).limit(100).parallel()    
	.forEach(i -> value1.incrementAndGet());
IntStream.iterate(1, i -> 1).limit(100).parallel()    
	.forEach(i -> ++value2[0]);

Difference?

value1 is atomic so no operation can overwrite another, ending on 100
value2 is not atomic so it can output any value 1 - 100


>
Which happens when more tasks are submitted to a thread executor than 
available threads?

internal queue for the tasks to wait until it can be executed!
call to wait is synchronous but thread executor is asynchronous


>
ForkJoin shit

int result = t1.fork().join();

means

The class produces single-threaded performance at runtime.

causing the process to wait, it does not perform any faster if there 
are 100 threads versus 1 thread,


>
System.out.println(Arrays.asList("duck","chicken","flamingo","pelican")
   .parallelStream()
   .parallel()
   .reduce(0, 
   		 (c1, c2) -> c1.length() + c2.length(), 
   		 (s1, s2) -> s1 + s2));

Problems?

what is the type of c1?

int because of the seed 0

what is the type of c2?

String because of the contents of the Stream<String>

can you call int.length()?

no, so code does not compile

.parallelStream().parallel()

is fine!


>
you lose parallel if the Collection.Characteristics is not UNORDERED 
and CONCURRENT or you use flatmap!



>
3: public void addAndPrintItems(BlockingDeque<Integer> deque) {
4:    deque.offer(103);
5:    deque.offerFirst(20, 1, TimeUnit.SECONDS);
6:    deque.offerLast(85, 7, TimeUnit.HOURS);
7:    System.out.print(deque.pollFirst(200, TimeUnit.NANOSECONDS));
:    System.out.print(" "+deque.pollLast(1, TimeUnit.MINUTES));
9: }

problems?

these Blocking methods, what do they do?

they throw an InterruptedException!

so you need to handle or declare that one, so does not compile

but if it compiled, what would be the output?

undetermined!

why?

Blockingqueue may not get execute time, so time may pass and the 
operations can fail


>
ExecutorService service = Executors.newScheduledThreadPool(10);
service.submit(Runnable)
service.execute(Runnable);

problem?

no! submit & execute exist on Es so no compile errors here!

what about the service in general?

not shutdown so runs forever.


>
service = Executors.newSingleThreadExecutor();
service.execute(() -> {sheepCount1.getAndIncrement(); sheepCount2++;});

problem?

what executor did we make and how many threads?

newSingleThreadExecutor() so 1 thread, so no concurrency!

meaning?

you can predict the output because no 2 threads can overwrite each
other anyway, both reach 100

>
infinite stream but limit(9)
cyclicbarrier of 10

never reached!

but ...

Note that even if the limit(9) statement was changed to limit(10), the
program could still hang, since the JVM might not allocate 10 threads 
to the parallel stream.



>
public static synchronized TicketManager getInstance() {
	+
public void sellTickets(int value) { synchronized (this) {

same object used for sync?

no, getInstance() = class and sellTickets() = static instance object



>
Applications with many resource-heavy tasks tend to benefit 

more from concurrency than ones with 

CPU-intensive tasks.













---------------  [[[CHAPTER 8]]] ------------------------p.406/458
















java.io API I/O streams are not Stream API streams at all


file + directory are treated the same in java
file system is in charge of reading and writing data


WHAT DOES THE FILE CLASS DO


1 read info about the files & directories
2 list contents of directory 
3 create/delete files & directories


WHAT CAN THE FILE CLASS NOT DO


read or write data within a file


WHAT IS AN ABSOLUTE AND RELATIVE PATH


1 absolute is from root directory to file or directory
2 relative is path to file or directory from a different start


HOW TO GET THE SEPARATOR FROM A SYSTEM


sout(System.getProperty("file.separator"));
sout(java.io.File.separator);
 ^ static helper variable in File


FILE CONSTRUCTORS


1 public File(String pathname)
2 public File(File parent, String child)
3 public File(String parent, String child)


WHAT IF THE PARENT FILE IS NULL


if with new File(parent, "data/stripes.txt") the parent is null
the constuctor will be skipped and the single String constructor 
will be used.


ARE YOU CONNECTED IF YOU MAKE A FILE OBJECT


no it only holds path to file or directory
it only connects if operated upon


FILE METHODS


//first methods, more info below
1  boolean 	delete()
2  boolean 	exists()
3  String 	getAbsolutePath()
4  String 	getName()
5  String 	getParent()
6  boolean 	isDirectory()
7  boolean 	isFile()	
8  long 		lastModified()
9  long 		length()	
10 File[] 	listFiles()
11 boolean 	mkdir() 
12 boolean 	mkdirs()	
13 boolean 	renameTo(File dest)

1  boolean delete()   		//true or false, dir must be empty
2  boolean exists()			//true or false
3  String getAbsolutePath()
4  String getName()   		//name of file or directory
5  String getParent() 		//get the parent dir of the path or null
6  boolean isDirectory() 	//true or false
7  boolean isFile()	     	//true or false
8  long lastModified()   	//ms since epoch of 12am jan 1 1970
9  long length()	     		//number of bytes in file, may be bigger
10 File[] listFiles()
11 boolean mkdir() 		 	//create dir of path
12 boolean mkdirs()		 	//create dir of path including parents
13 boolean renameTo(File dest) //only true if succesvol


WHAT TO LOOK OUT FOR WITH DELETE()


if its a dir, it must be empty


BIG EXAMPLE


import java.io.File;
public class ReadFileInformation {   
	public static void main(String[] args) {
		File file = new File("C:\\data\\zoo.txt");
		System.out.println("File Exists: "+file.exists());      
		if(file.exists()) { 
			System.out.println("Absolute Path: "+file.getAbsolutePath());
			System.out.println("Is Directory: "+file.isDirectory());
			System.out.println("Parent Path: "+file.getParent());      
			if(file.isFile()) {            
				System.out.println("File size: "+file.length());
				System.out.println("File LastMod: "+file.lastModified());
			} else {            
				for(File subfile: file.listFiles()) {
				System.out.println("\t"+subfile.getName());
}}}}}

the output of this code depends on the filesystem at runtime!


WHAT DOES FILE ACTUALLY POINT TO AND WHAT IS THE PARENT 


File file = new File("c:\\data\\zoo.txt");
File = c:\data\zoo.txt
Parent = c:\data

File file = new File("c:\\data");
File = c:\data
Parent = c:\


DOES AN EXTENSION ALWAYS MEAN ITS A FILE


No! Never assume it is a file or directory 
For example, /data/zoo.txt could be a file or a directory


HOW TO WRITE AN ABSOLUTRE PATH STRING FOR WINDOWS


double \\ to escape the \ character: C:\\data\\zoo.txt


BYTE STREAMS VS CHARACTER STREAMS - DIFFERENCES


reads binary data (0s/1s)
class names end in InputStream / OutputStream (FileInputStream)
used for images and executables

reads text data (char and Strings)
class names end in Reader / Writer (FileReader)
used for text files

despite names both are input streams or output streams


BENEFIT OF CHARACTER STREAMS OVER BYTE STREAMS FOR TEXT


You dont have to worry about the character encoding of the file
UTF-8 or ASCII or UTF-16


WHAT ARE LOW AND HIGH LEVEL STREAMS


low-level: directly connecting to the source file, string or array
	      reads byte for byte
high-level: built on top of another stream and uses wrapping


WHAT IS WRAPPING


The process by which an instance is passed to the constructor of 
another class, and operations on the resulting instance are filtered 
and applied to the original instance.
try (var br = new BufferedReader(new FileReader("zoo-data.txt"))) {
   System.out.println(br.readLine());
}
buffered is high-level and takes a low-level filereader
try (var ois = new ObjectInputStream(
		     new BufferedInputStream(
		     new FileInputStream("zoo-data.txt")))) {   
		     	System.out.print(ois.readObject());
			}


ABSTRACT CLASSES OF JAVA.IO


these are the abstract parent classes of all stream classes
inputstream 	Abstract class for all input byte streams
outputstream 	Abstract class for all output byte streams
reader 			Abstract class for all input character streams
writer 			Abstract class for all output character streams


WHAT DOES INPUT and OUTPUT MEAN


input = reading data from a resource / file
output = writing data to a resource / file

ObjectInputStream = 

reading data from a resource into a primitive object

creating a primitive from a stream = 

deserializing the stream

creating an outputstream from a primitive =

serializing the primitive to an outputstream



DETECT COMPILE ISSUES WITH THESE CLASSES


1 high-level streams need to take the correct low-level stream class
2 dont mix inputstream/outputstream with reader/writer classes
3 dont mix inputstream/reader with outputstream/writer classes
4 dont instantiate the abstract parent classes themselves
new BufferedInputStream(new FileReader("z.txt"));
new BufferedWriter(new FileOutputStream("z.txt"));
new ObjectInputStream(new FileOutputStream("z.txt"));
new BufferedInputStream(new InputStream());


REVIEW OF JAVA.IO CLASS NAME PROPERTIES


1 A class with the word InputStream or OutputStream in its name is 
	used for reading or writing binary or byte data, respectively.
2 A class with the word Reader or Writer in its name is used for 
	reading or writing character or string data, respectively.
3 Most, but not all, input classes have a corresponding output class.
4 A low‐level stream connects directly with the source of the data.
5 A high‐level stream is built on top of another stream using 
	wrapping.
6 A class with Buffered in its name reads or writes data in groups 
	of bytes or characters and often improves performance in sequential 
	file systems.
7 With a few exceptions, you only wrap a stream with another stream 
	if they share the same abstract parent.


STREAM CLASSES YOU NEED TO KNOW AND FIGURE OUT BY THEIR NAME


1  FileInputStre am  		//bytes
2  FileOutputStream
3  FileReader       		//characters
4  FileWriter
5  BufferedInputStream  //buffers to improve efficiency and perf
6  BufferedOutputStream
7  BufferedReader
8  BufferedWriter
9  ObjectInputStream 	//deserializes primitives to inputstream
10 ObjectOutputStream	//serializes primitives to outputstream
11 PrintStream //writes and formats java objects to binary stream
12 PrintWriter //writes and formats java objects to char stream
13 InputStreamReader 	//read  char data from existing inputstream
14 OutputStreamWriter 	//write char data to   existing outputstream

only 1-4 are low-level streams


WHAT ARE THE BUILT IN STREAMS JAVA PROVIDES


System.in, System.err, and System.out


MOST IMPORTANT I/O METHODS FOR ALL STREAMS


// InputStream and Reader
public int read() throws IOException
// OutputStream and Writer
public void write(int b) throws IOException
//all streams
public void close()


DO I/O STREAMS IMPLEMENT CLOSEABLE OR AUTOCLOSEABLE


yes, Closeable(!) because as resources they need to be closed


DO YOU NEED TO CLOSE ALL STREAMS ALWAYS


no, wrapped streams are closed by closing the top-level one 1x


OVERLOADED METHODS FOR INPUT STREAMS


int 	read() 	throws IOException
int 	read(byte[] b) 	throws IOException
int 	read(char[] c) 	throws IOException
int 	read(byte[] b, int offset, int length) 	throws IOException
int 	read(char[] c, int offset, int length) 	throws IOException


OVERLOADED METHODS FOR OUTPUT STREAMS


void 	write(int b)
void 	write(byte[] b) 	throws IOException
void 	write(char[] c) 	throws IOException
void 	write(byte[] b, int offset, int length) 	throws IOException
void 	write(char[] c, int offset, int length) 	throws IOException

Writer append(CharSequence csq) throws IOException


WHAT DO THE OFFSET AND LENGTH REPRESENT


offset and length are applied to the array
length is number of elements to read/write
offset is from where to start reading/writing in the array



WHY INT AND NOT BYTE


they needed an extra char to indicate end of stream as -1 on top of 
the 256 characters from byte


WHAT DOES READ RETURN IF NO BYTES AVAILABLE


-1


HOW TO COPY A STREAM EXAMPLE


take an inputstream/reader and copy to outputstream/writer
void copy(InputStream in, OutputStream out) throws IOException {
   int b;   
   while ((b = in.read()) != -1) { out.write(b); }
}

public static void main(String[] args) throws IOException {        
	File source = new File("Zoo.class");        
	File destination = new File("ZooCopy.class");        
	copy(source,destination);     		
}


WHAT HAPPENS IF THE DESTINATION FILE ALREADY EXISTS


it gets overwritten


WHERE WILL THE APP LOOK FOR THE SOURCE FILE ON FILE SYSTEM


current working directory


WHAT HAPPENS IF THE SOURCE FILE DOES NOT EXIST


FileNotFoundException = subclass of IOException


HOW TO IMPROVE THE ABOVE EXAMPLE FOR PERFORMANCE


use buffers
dont use int read() but int read(byte[]) instead


WHAT DOES THE RETURN OF READ(BYTE[]) REPRESENT


the number of bytes that were written into the array


WHY IS THAT IMPORTANT


because if that number is 0, you know you are EoF


HOW MANY BYTES WILL BE WRITTEN INTO THE ARRAY PER TURN


the buffersize, for example 1024 bytes
got an array with less than 1024 bytes? you are at EoF


WHAT DOES WRITE(BYTE[], 0, 1024) MEAN


write the passed in byte[] to file skipping 0 bytes and writing 1024


WHY EXACTLY IS A BUFFERED STREAM SO USEFUL IF YOU CAN USE BYTE[]


because buffered streams can do read() many times into memory before
having to write to file


NEW COPY EXAMPLE


import java.io.*;

public class CopyBufferFileSample {   
	public static void copy(File s, File d) throws IOException {      
		try (InputStream in   = new BufferedInputStream(
									   new FileInputStream(s));         
			  OutputStream out = new BufferedOutputStream(
			  						   new FileOutputStream(d)) )
			{
				byte[] buffer = new byte[1024];         
				int lengthRead;         
				while ((lengthRead = in.read(buffer)) > 0) {            
					out.write(buffer,0,lengthRead);            
					out.flush();
}}}}

out.write(buffer,0,lengthRead); = write(byte[], offset, length)

flush() ensures that

written data actually gets written to disk before the nnext read()


BEST WAY TO CLOSE I/O STREAMS


They all implement Closeable so use try-with-resources


WHERE SHOULD YOU CLOSE THE I/O STREAM IF PASSED TO METHOD


in the method that created the stream not the one using it


WHAT IS THE PREFERRED WAY OF CLOSING HIGH-LEVEL STREAMS


combine them into one and you only have to close the top one
bad example:
try (var fos = new FileOutputStream("zoo-banner.txt");
	var bos = new BufferedOutputStream(fos);         
	var oos = new ObjectOutputStream(bos)) {
		oos.writeObject("Hello");    
}
good example:
try (var oos = new ObjectOutputStream(          
     new BufferedOutputStream(             
     new FileOutputStream("zoo-banner.txt")))) {       
     	oos.writeObject("Hello");    
}


MANIPULATING INPUT STREAM METHODS


// InputStream and Reader
public 	boolean 	markSupported()
public 	void 	mark(int readLimit)
public 	void 	reset()	throws IOException
public 	long 	skip(long n)	throws IOException


WHY IS MARKSUPPORTED() IMPORTANT


you should call markSupported() to see if mark() and reset() are 
available to the stream class else exception


WHAT DO MARK AND RESET DO


mark(int) 	how many bytes should be read
reset()  	sets stream back at the mark point
public void readData(InputStream is) throws IOException {   
	System.out.print((char) is.read());     // L   
	if (is.markSupported()) {
		is.mark(100);  // Marks up to 100 bytes      
		System.out.print((char) is.read());  // I      
		System.out.print((char) is.read());  // O      
		is.reset();    // Resets stream to position before I   
	}   
	System.out.print((char) is.read());    // I   
	System.out.print((char) is.read());    // O   
	System.out.print((char) is.read());    // N
}
LIOION or LION if markSupported() is false


WHAT HAPPENS IF YOU RESET AFTER READING MORE THAN MARK BYTES


possible exception depending on stream class
some classes use a buffer to allow more reading but at some point
the data is gone and you will get an exception


WHY SHOULDNT YOU USE MARK/RESET WITH LARGE VALUES


it copies to a temp buffer in memory so it can hog memory


WHAT DOES MARK() DO EXACTLY


you reset to the point in the stream you marked, but it doesnt 
actually put read bytes back in the stream, you reset to the point
of the stream and mark puts that part of the stream in memory again


WHAT DOES SKIP() DO


reads data but doesnt do anything with it
skipping is same as reading data but not doing anything with output


IS SKIP BENEFICIAL TO USE OVER JUST READING AND DISREGARDING


for a large number of bytes it is a lot faster because it uses arrays


WHY IS THE RETURN PARAMETER OF SKIP IMPORTANT


the long param tells you have many values were actually skipped
this way you know where you are in the stream
skip(1000) but returns 20? only 20 are skipped, you are not at 
pos1000


WHAT DOES FLUSH() METHOD DO


it forces the JVM or OS to write to the filesystem


WHY IS THIS NECESSARY


because data to an OutputStream is not written immediately
so if you crash its bye bye data
flush forces a write at the cost of performance


WHEN IS FLUSH() USED AUTOMATICALLY


close() automatically uses flush()


WHEN SHOULD YOU USE FLUSH()


for critical data and intermittently


WHAT TYPES DO STREAMS AND READER/WRITERS USE


streams use byte[] and reader/writer use char[]


CONSTRUCTORS TO CONNECT STREAMS TO FILES (LOW-LEVEL)


public 	FileInputStream (File file)	throws FileNotFoundException
public 	FileInputStream (String name)	throws FileNotFoundException
public 	FileOutputStream(File file)	throws FileNotFoundException
public 	FileOutputStream(String name)	throws FileNotFoundException
public 	FileReader(File file)	throws FileNotFoundException
public 	FileReader(String name)	throws FileNotFoundException
public 	FileWriter(File file)	throws FileNotFoundException
public 	FileWriter(String name)	throws FileNotFoundException


WHAT IS THE APPEND FLAG


to tell your stream to add to the end if the file already exists
otherwise it will overwrite it


HIGH-LEVEL BUFFER CONSTRUCTORS


public BufferedInputStream(InputStream in)
public BufferedOutputStream(OutputStream out)

public BufferedReader(Reader in)
public BufferedWriter(Writer out)


WHAT METHOD IS AVAILABLE ONLY FOR FILEWRITER AND NOT FILEOUTPUTSTREAM


// from Writer.class
public void write(String str) throws IOException
writer.write("Hello World");


WHAT METHODS ARE IN BUFFERED READER BUT NOT IN BUFFEREDINPUTSTREAM


readLine() and newLine()
// BufferedReader
public String readLine() throws IOException
// BufferedWriter
public void newLine() throws IOException


EXAMPLE OF THESE METHODS AND WHY THEY ARE USEFUL


void copyTextFileWithBuffer(File src,File dest) throwsIOException {   
try (var reader = new BufferedReader(new FileReader(src));        
	 var writer = new BufferedWriter(new FileWriter(dest))) {      
	String s;      
	while ((s = reader.readLine()) != null) {
		writer.write(s);
		writer.newLine();      
}}}
stores data in a String instead of char[]
this means String methods are available! like toUpperCase()
we read an entire line instead of bytes
if no line exists we return null
write(String) writes entire line at once


WHAT DOES NEWLINE() DO


readLine() strips out the line break character
newLine() puts the line break character back in otherwise you would 
have a text file with no line breaks


WHAT IS SERIALIZATION


The process of converting an in-memory object to a byte stream.
Serialize object to stream.
You take a complex object and to write it to a file you use a stream.
To get that stream you need to serialize the object into a stream.


WHAT IS DE-SERIALIZATION


The process of converting a byte stream to an in-memory object.
De-serialize stream to object.


CONNECTION IN-MEMORY OBJECTS AND FILE SYSTEM


file system <----> JVM
giraffe.txt <----> var g = New Giraffe();


HOW TO SERIALIZE AN OBJECT


implement java.io.Serializable interface (marker interface!!)
need an import!
has no methods, just marks class for serialization


WHAT DOES MARKER INTERFACE MEAN


The interface has no methods.


WHY NOT MARK EVERYTHING FOR SERIALIZABLE


You should only mark data-oriented classes. Other proces related
classes are ephemeral or short-lived which makes serialization
pointless.


WHAT STUFF IS SERIALIZED


instance members
not transient members


WHAT IS TRANSIENT AND HOW DOES IT WORK


it marks a member to not be part of the serialized object meaning
the value will not be passed to the stream
after serialization (stream back into object) the transient member 
reverts back to its default value 0, 0.0 or null


HOW TO MAKE A CLASS SERIALIZABLE + EXAMPLE


1 The class must implement the Serializable interface.
2 EVERY instance member of the class is either:
	a serializable, 
	b marked transient, or 
	c has a null value at the time of serialization.


public class Cat implements Serializable {
	private Tail tail = new Tail();
}
public class Tail implements Serializable {
	private Fur fur = new Fur();
}
public class Fur {}


IS CAT SERIALIZABLE


No, because Fur is not serializable


SOLUTIONS


make Fur serializable
make Tail in Cat transient


WHY IS MAKING FUR REFER TO NULL NOT A GREAT SOLUTION


Because then Cat will be serializable only for some instances.


WHAT HAPPENS IF YOUR CLASS IS NOT PROPERLY SERIALIZABLE


NotSerializableException


SERIALIZATION CONSTRUCTORS + METHODS


public ObjectInputStream(InputStream in) throws IOException
public ObjectOutputStream(OutputStream out) throws IOException

// ObjectInputStream
public Object readObject() throws IOException,ClassNotFoundException
// ObjectOutputStream
public void writeObject(Object obj) throws IOException

ObjectInputStream  deserializes stream into an object
ObjectOutputStream serializes   object into a  stream

 
EXAMPLE OF SERIALIZATION TO A FILE


void saveToFile(List<Gorilla> grs, File data) throws IOException{   
try (var out = new ObjectOutputStream(           
			   new BufferedOutputStream(              
			   new FileOutputStream(data)))) {      
				for (Gorilla gorilla : gorillas) 
					out.writeObject(gorilla); 
	}
 }
 Pretty easy, right? Notice we start with a file stream, wrap it in a 
 bufferedstream to improve performance, and then wrap that with an 
 object stream. Serializing the data is as simple as passing it to 
 writeObject().


EXAMPLE OF DESERIALIZATION OF A FILE


 List<Gorilla> readFromFile(File dataFile) throws IOException,      
 									ClassNotFoundException {   
var gorillas = new ArrayList<Gorilla>();   
try (var in = new ObjectInputStream(           
 			  new BufferedInputStream(              
 			  new FileInputStream(dataFile)))) {      
 				while (true) {         
 					var object = in.readObject();         
 					if (object instanceof Gorilla)
            			gorillas.add((Gorilla) object); // CAST!!!
            	}
       	} catch (EOFException e) {      
       		// File end reached   
  		}   
	return gorillas;
}


ARE THERE IMPORTANT RETURN VALUES WITH READOBJECT()


no, -1 and null do not matter since those can be actual values


WHY DO YOU NEED A CAST 


because you are working with objects


WHY THE INFINITE LOOP


because you dont know how big the file is
at the end EOFException will be thrown


HOW IS A DESERIALIZED OBJECT CREATED


1 The constructors and any instance initializers are not called on 
	creation!!!
2 The no-args constructor of the first nonserializable class is 
	called, usually Object.
3 static and transient members are ignored
4 if a value is not provided it will get the default value
Chimp is marked Serializable.
Chimp has 2 constructors and an instance initializer, setting values.
Chimp has 3 members, 2 transient and 1 static.
If you serialize a Chimp, none of the values are saved to file.
If you de-serialize a Chimp, all the transient members get a default 
while the static member gets displayed as the last value set.
Class is still initialized on startup and sets the static member to C.


WHICH CLASSES FOR PRINTING DATA TO SCREEN + CONSTRUCTORS


printstream classes 

public PrintStream(OutputStream out)
public PrintStream(File file) 		throws FileNotFoundException
public PrintStream(String fileName) throws FileNotFoundException

public PrintWriter(Writer out)
public PrintWriter(OutputStream out) !! unique constructor combo!!
public PrintWriter(File file) 		throws FileNotFoundException
public PrintWriter(String fileName) throws FileNotFoundException


LOW-LEVEL CLASS + DIFFERENCE OF OTHER STREAM CLASSES


no corresponding input classes
use OutputStream and Writer
doesnt have OutputStream in the name


ONLY EXCEPTION OF MIXING BYTE AND CHAR STREAM


PrintWriter has a constructor to take an OutputStream
public PrintWriter(OutputStream out)


WHAT ARE TWO EXAMPLES OF COMMON PRINTSTREAM OBJECTS


System.err and System.out are PrintStream objects!!


DO PRINT STREAM CLASSES THROW AN EXCEPTION AND WHY


No, because otherwise you would have to catch checked exceptions 
every time you used System.out.print()

write throws

an IOException that must be handled or declared

print println etc do not throw anything!


WHAT DOES CHECKERROR() DO


method in print stream classes can be used to check for an error 
after a write


WHAT CLASSES DO PRINTSTREAM/PRINTWRITER INHERIT FROM


PrintStream inherits from OutputStream
PrintWriter inherits from Writer

this means both Print classes have the method

void write(int)

but they provide their own convenience methods like print()


HOW DOES PRINT() WORK IN RELATION TO WRITE() + EXAMPLES


print() has overloadeded methods for:

- all primitives
- String
- Object

these overloaded methods just use String.valueOf() on the argument 
and call write()
out.print(5);                  // PrintWriter method
out.write(String.valueOf(5));  // Writer method   

out.print(animal);                              	  // PrintWriter
out.write(animal==null ? "null": animal.toString()); // Writer method


PRINTLN() + SEPERATORS


println() is print() with a line break
useful because line breaks can be different
System.getProperty("line.separator");
System.lineSeparator();


PRINTSTREAM METHODS RECAP


print() ,  println() ,  format() , and  printf()



>>>  You might remember from Chapter   5   that  String  formatting is
 no longer a part of the OCP 8 exam. For the exam, you should be aware
  that the  Consoleclass includes two methods,  format()  and  printf()
   , which take an optional vararg and format the output, although 
   you’re no longer required to know the various rules for formatting 
   for the exam. For this chapter, we will provide the first  String
     argument to these methods only.



WAYS TO FORMAT WITH PRINT STREAM CLASSES


// PrintStream
public PrintStream format(String format, Object args...)
public PrintStream format(Locale loc, String format, Object args...)
// PrintWriter
public PrintWriter format(String format, Object args...)
public PrintWriter format(Locale loc, String format, Object args...)


FORMAT EXAMPLES


String name = "Lindsey";
int orderId = 5;
// Both print: Hello Lindsey, order 5 is ready
System.out.format("Hello "+name+", order "+orderId+" isready");
System.out.format("Hello %s, order %d is ready", name,orderId);


PRINT STREAM FORMAT SYMBOLS


%s any type usually String
%d integer values int and long
%f floating-points float and double
%n line break using system dependent line separator


DEFAULT FORMAT OF %F


six digits after . : 90.25 = 90.250000


EXAMPLE


String name = "James";
double score = 90.25;
int total = 100;
System.out.format("%s:%n   Score: %f out of %d", name, score,total);
This prints the following:
James:   
Score: 90.250000 out of 100


SETTING OF %F


default 6 digits after decimal
uses rounding
%.1f = all before decimal but 1 digit after decimal
%12.8f = 12 digits max including decimal and 8 digits after decimal
with a max digits empty space is filled with blank spaces
with %012.8f you fill empty space with 000000
examples:
var pi = 3.14159265359;    
System.out.format("[%f]",pi);      // [3.141593]     standaard 6 na .
System.out.format("[%12.8f]",pi);  // [  3.14159265]    
System.out.format("[%012f]",pi);   // [00003.141593] standaard 6 na .
System.out.format("[%12.2f]",pi);  // [        3.14]    
System.out.format("[%.3f]",pi);    // [3.142]
var getal = 12345.12345;
System.out.format("%6.3f" ,getal); //[12345,123] toch meer dan 6 digit
Locale can turn 3.14 into 3,14


WHAT HAPPENS IF YOU USE WRONG SYMBOL


System.out.format("Food: %d tons", 2.0);
//IllegalFormatConversionException


DOES FORMAT() USE A LINE BREAK


No! If you want a line break, insert println() after


WHAT DOES PRINTF() DO


its a C version of format()


WHY ARE INPUTSTREAMREADER AND OUTPUTSTREAMWRITER CONVENIENT


they wrap a bytestream with a charstream
have both in/outputstream and reader/writer in their name
Reader r = new InputStreamReader(System.in);         
Writer w = new OutputStreamWriter(System.out);


WHAT ARE THE FILTERINPUTSTREAM / FILTEROUTPUTSTREAM CLASSES


high‐level superclasses that filter or transform data. They are 
rarely used directly.


USE P.1281 DIAGRAM TO SEE IF YOU KNOW ALL CLASSES


DIFFERENCES BETWEEN SYSTEM.OUT AND SYSTEM.ERR


handle the same way
on console both print text
in IDE maybe different colors
on server write to different logs


WHEN DOES SYSTEM.IN FETCH DATA


when user presses enter


WHY DONT YOU CLOSE SYSTEM.OUT/IN/ERR


they are static objects and the JVM creates and opens them for you
closing them is not recommended ever


WHAT HAPPENS IF YOU CLOSE SYSTEM.OUT AND THEN PRINT SOMETHING


nothing happens, PrintStream methods do not throw checked exceptions 
so they fail silently


HOW CAN YOU CHECK A FAILED SYSTEM.OUT


checkerror()


WHY IS CLOSING SYSTEM.ERR ESPECIALLY BAD


because you no longer have stacktraces


WHEN WILL YOU GET AN EXCEPTION AFTER CLOSING STREAMS


not with PrintStream classes but you will get with InputStream


WHAT IS THE CONSOLE CLASS


A better way of interacting with the user than System.in System.out

System.in returns an

InputStream

System.out returns a

PrintStream

BufferedReader reader = new BufferedReader(new InputStreamReader(
																System.in));
the bufferedreader allows input until <enter>

you need an InpuStreamReader to convert to a Reader

no try-with-resources here!! because

closing System.in means you cant take input for the program anymore


DOES CONSOLE HAVE A CONSTRUCTOR


no, they are all private
Console c = new Console();  // DOES NOT COMPILE


WHAT SORT OF CLASS IS CONSOLE


singleton: only usable with factory method and only 1 instance 
allowed

it is autocreated by the JVM


WHAT IS THE CONSOLE FACTORY METHOD


System.console();
example:
Console console = System.console();
if (console != null) {   
	String userInput = console.readLine();
	console.writer().println("You entered: " + userInput);
} else {   
	System.err.println("Console not available");
}


WHY DO YOU NEED TO CHECK FOR NULL AFTER SYSTEM.CONSOLE()


console may not be available and only 1 is allowed
always check for null to see if you really got it


CONSOLE CLASS METHODS - HOW TO ACCESS READER AND WRITER OBJECTS


public Reader 			reader()
public PrintWriter   writer()

these methods are analogous to

System.in and System.out

difference is charstreams vs bytestreams
 

CONSOLE CLASS METHODS - HOW TO OUTPUT DATA TO USER


use the writer() method to produce a PrintWriter object or use
the convenience method:
public Console format(String format, Object... args)

is there a locale overloaded version?

no!

console.format = String.format only it uses default locale

if you need a different locale, use console.writer.format


CONSOLE CLASS METHODS - RETRIEVE DATA FROM USER


public String 			readLine()
public String 			readLine(String fmt, Object... args)


CONSOLE CLASS METHODS - RETRIEVE PASSWORD FROM USER


public char[] 			readPassword()
public char[] 			readPassword(String fmt, Object... args)


CONSOLE CLASS METHODS - PROPERLY USE READLINE OR READPASSWORD


public void 				flush()
to prevent text lingering in the buffer
you might end up with a user prompt with no text preceding it


DIFFERENCE BETWEEN READER() WRITER() AND SYSTEM.IN AND OUT


system.in/out uses byte streams 
reader() writer() uses character streams


DIFFERENCE BETWEEN FORMAT() WRITER.FORMAT()


with Console you can skip calling writer and just output data in 
single stream
public Console format(String format, Object... args)
public Console printf(String format, Object... args)
The format() method behaves the same as the format() method on 
the stream classes


DO CONSOLE AND PRINT STREAM CLASSES OVERLOAD WITH LOCALE


print stream classes do
console does not


HOW DO YOU LOCALE WITH CONSOLE


Console uses system locale but you can use a Writer object to specify 
a different locale
Console console = System.console();    
console.writer().format(new Locale("fr", "CA"),"Hello World");


METHODS OF CONSOLE TO RETRIEVE REGULAR DATA FROM USER


public String readLine()
public String readLine(String fmt, Object... args)
public char[] readPassword()
public char[] readPassword(String fmt, Object... args)


WHICH METHODS WAIT ON USER <ENTER> KEYPRESS


1 System.in with a BufferedReader
2 Console readLine()


DIFFERENCE BETWEEN READPASSWORD() AND READLINE()


1 The text the user types is not echoed back and displayed on the 
screen as they are typing.
2 The data is returned as a char[] instead of a String.


WHY IS REASON #2 IMPORTANT


to prevent password entering the string pool


EXAMPLE


console.writer().print("How excited are you about your trip today? ");
console.flush();
String excitementAnswer = console.readLine();
String name = console.readLine(“Please enter your name: “);
Integer age = null;
console.writer().print("What is your age? ");
console.flush();
BufferedReader reader = new BufferedReader(console.reader());
String value = reader.readLine();
age = Integer.valueOf(value);
console.writer().println();
console.format("Your name is "+name);
console.writer().println();
console.format("Your age is "+age);
console.printf("Your excitement level is: "+excitementAnswer);


MAIN SEGMENTS OF I/O STREAMS


1 input and output
2 byte and char streams
3 low-level and high-level


CHAPTER QUESTIONS


>
sb.append((char)is.read());

this is valid!
int read() returns an int representing a byte which you can cast

>
high-level streams can wrap other high-level streams

>
Why does Console.readPassword() return a char[] array instead of a 
String object?

char[] doesnt enter string pool

value can be erased immediately

and thats what its also more secure

writer().append() ???? exists?

>
The readObject() method of ObjectInputStream may throw a 
ClassNotFoundExceptioneven if the return object is not explicitly cast.

true! creating the object in the class Object may throw a CNFex

>
A.new File("c:\book\java");
B.new File("c:\\book\\java");
C.new File("c:/book/java");
D.new File("c://book//java");

which ones are right?

not A because not escaped

B & C & D are correct

why C & D?

java will fix the wrong / escaped or not

>
bufferedReader.readLine() ???? exists?

>
Note that seri-alUID is not the same as serialVersionUID, although 
since serialVersionUID is recom-mended but not required, this does not
 pose any compilation issues. Just be aware that serialUID will not be 
 used by the serialization process for version control.

>

public class Zebra implements Serializable {   
	private static final long serialUID = 1L;   
	private transient String name = "George";   
	private static String birthPlace = "Africa";   
	private transient Integer age;   
	private java.util.List<Zebra> friends = new java.util.ArrayList<>();
	private Object tail = null;   { age = 10;}   
	public Zebra() {      
	this.name = "Sophia";   
}}

~which values will be null on deserialization

name + age because 

they are transient

birthPlace? 

static does not get serialized

friends?

no, an empty serialized arrayList is not a null pointer!

tail?

no, could be set by a caller before hand

















---------------  [[[CHAPTER 9]]] ------------------------p.454/506









java.nio version 2 API
NIO.2 for short, to interact with files
second version of the Non‐blocking Input/Output API,
New I/O


WHAT IS PATH


interface
java.nio.file.Path
the File of NIO.2 but File was a class and Path is an interface


SIMILARITIES OF PATH AND FILE


objects refer to absolute or relative path within the file system
both may refer to a file or a directory
directory=file, same thing in java, same commands to change it


WHAT IS NEW TO THE PATH INTERFACE


symbolic links


WHAT IS A SYMBOLIC LINK


a special file within a file system that serves as a reference or 
pointer to another file or directory


HOW TO CREATE A PATH


its an interface so no constructors
static factory method
// Path factory method
public static Path of(String first, String... more)  // PATH.OF(...)
Path path1 = Path.of("pandas/cuddly.png");
Path path2 = Path.of("c:\\zooinfo\\November\\employees.txt");
Path path3 = Path.of("/home/zoodirectory");
1 = relative path, 2&3 absolute paths


ABSOLUTE VS. RELATIVE PATHS


1 If a path starts with / => absolute, with / as the root directory.
2 If a path starts with c: => absolute, driveletter = root directory.
3 Otherwise, it is a relative path.


WHAT DOES THE VARARGS DO IN THE PATH FACTORY METHOD


allows user to give values which are combined to a path with system 
dependent file separators
this way you dont have to worry about correct system syntax!
Path path1 = Path.of("pandas", "cuddly.png");
Path path2 = Path.of("c:", "zooinfo", "November","employees.txt");
Path path3 = Path.of("/", "home", "zoodirectory");


OTHER WAY TO CREATE A PATH INSTANCE


with the older java.nio.file.Paths factory class
// Paths factory method
public static Path get(String first, String... more) //PATHS.GET(...)


THIRD WAY OF GETTING A PATH


With the URI class
jave.net.URI
uniform resource identifier


HOW IS AN URI STRUCTURED


1 schema to indicate resource type like http:// ftp:// or file://
2 path value


HOW TO CREATE URI VALUE


// URI Constructor
public URI(String str) throws URISyntaxException


CAN YOU CONVERT BETWEEN PATH AND URI


// URI to Path, using Path factory method
public static Path of(URI uri)
// URI to Path, using Paths factory method
public static Path get(URI uri)
// Path to URI, using Path instance method
public URI toURI()
EXAMPLES
URI a = new URI("file://icecream.txt");
Path b = Path.of(a);
Path c = Paths.get(a);
URI d = b.toUri();


IS THIS A GOOD SYNTAX


Path path1 = Paths.get(new URI("file://pandas/cuddly.png")); 

no! the trick is looking at the number of / in the string

URI must always point to absolute paths at runtime
this string resolves to file://     pandas/cuddly.png = relative ....

Path path2 = Paths.get(new URI("file:///c:/zoo-info/Nov/employs.txt"));
Path path3 = Paths.get(new URI("file:///home/zoodirectory"));


PRACTICE

Paths path1 = Paths.get("/alligator/swim.txt");
Path path2 = Path.get("/crocodile/food.csv");


CAN YOU GET URI FOR WEBPAGE OR FTP


yes but you do not need to know the syntax

Path path4 = Paths.get(new URI("http://www.wiley.com"));
Path path5 = Paths.get(new URI("ftp://user:pass@ftp.the-ftp.com"));

 throws URISyntaxException!!!! because of new URI


WHAT IS THE LONG WAY TO GET A PATH


1 abstract class FileSystem
2 get instance with factory class FileSystems
3 // FileSystems factory method
public static FileSystem getDefault()
4 // FileSystem instance method
public Path getPath(String first, String... more)


WHAT IS THE RELATION BETWEEN PATH AND FILESYSTEMS


both Paths.get() and Path.of() are actually shortcuts for this 
FileSystem method: public Path getPath(STR,STR)
Path path1 = FileSystems.getDefault().getPath("pandas/cuddly.png");
Path path2 = FileSystems.getDefault()
		.getPath("c:","zooinfo","November","employees.txt");
Path path3 =FileSystems.getDefault().getPath("/home/zoodirectory");


WHAT IS A MAJOR CONNECTING BENEFIT OF NIO.2 OVER FILE


with NIO.2 you can connect to local and remote filesystems

FileSystem fileSystem = FileSystems
	.getFileSystem(new URI("http://www.selikoff.net"));
Path path = fileSystem.getPath("duck.txt");


LAST WAY TO GET A PATH


From legacy java.io.File class to Path
And Path to File
// Path to File, using Path instance method
public default File toFile()	//path.toFile();
// File to Path, using java.io.File instance method
public Path toPath() 			//file.toPath();



Path.of(String, varargs...)
Path.of(URI)
Paths.get(String, varargs...)
Paths.get(URI)
new URI(String) throws URISyntaxException
FileSystems.getDefault().getPath(String, varargs...)
File toFile()
Path toPath()



IMPORTANT NIO.2 RELATIONSHIPS TO MEMORIZE


FileSystems --creates--> FileSystem --creates--> Path
                              Paths --creates--> Path //Paths.get()
                               Path --creates--> Path //Path.of()
Path <--converts --> java.io.File
Path <--converts --> jave.net.URI
java.nio.file.Files --uses--> Path


UNDERSTAND THE (NON)RELATIONSHIP BETWEEN FILE AND FILES


(java.io.)File is old and (java.nio.file.)Files is new
Files does NOT operate on File instances
Files operates on Path instances


FACTORY AND HELPER CLASS DEFINITIONS


Factory is for object creation
Helper is for operating on instances


WHAT ARE PATH SYMBOLS AND WHAT DO THEY REPRESENT


reserved series of characters that have special meaning within some 
filesystems
 . = ref to current dir
.. = ref to parent of current dir  
../../file.txt = 2 directories up from where file.txt is


COMMON NIO.2 METHOD ARGUMENTS


NIO.2 methods have a varargs to pass optional values:
LinkOption
StandardCopyOption
StandardOpenOption
FileVisitOption


LinkOption.NOFOLLOW_LINKS
-> implements CopyOption OpenOption

StandardCopyOption.ATOMIC_MOVE	  
StandardCopyOption.COPY_ATTRIBUTES	  
StandardCopyOption.REPLACE_EXISTING  
-> implements CopyOption

StandardOpenOption.APPEND 	   	//if file already open append
StandardOpenOption.CREATE      	//create new if not exist
StandardOpenOption.CREATE_NEW  	//create new if not exist, else fail
StandardOpenOption.READ        	//open for read access
StandardOpenOption.TRUNCATE_EXISTING
StandardOpenOption.WRITE 	   	//open for write access
-> implements OpenOption

FileVisitOption.FOLLOW_LINKS
-> does not implement


WHAT DOES NOFOLLOW_LINK DO


Normally .exists() checks if the file exists. If a symbolic link is 
passed, it checks if the target exists.
NOFOLLOW_LINK overrides this behavior and checks if the symbolic link 
ITSELF exists instead.
In general, use this option if you want to perform operations on links


WHAT DOES TRUNCATE_EXISTING DO


if the file is already open for write, erase file and append to 
beginning


COMMON REASONS FOR GETTING AN IOEXCEPTION


1 Loss of communication to underlying file system.
2 File or directory exists but cannot be accessed or modified.
3 File exists but cannot be overwritten.
4 File or directory is required but does not exist.


WHAT METHODS THROW CHECKED EXCEPTION GENERALLY AND WHICH DONT


1 methods that operate on abstract Path values, such as those in the 
Path interface or Paths class, often do not throw any checked 
exceptions. 
2 methods that operate or change files and directories, such as those 
in the Files class, often declare IOException.


WHAT IS AN EXCEPTION TO THIS RULE


the method Files.exists() does not declare IOException. If it did 
throw an exception when the file did not exist, then it would never 
be able to return false!


ARE PATH INSTANCES IMMUTABLE


yes
with chaining you get a new Path instance everytime to work with


WHEN SHOULD THE PATH REFERRED TO ACTUALLY EXIST


usually when the method declares IOException, otherwise it does not 
have to exist


HOW DO TOSTRING(), GETNAMECOUNT(), AND GETNAME(INT) WORK


public String toString() 

returns the entire path as String

public int  getNameCount() 

returns the number of elements in the path

public Path getName(int index) 

returns the element on index


WHAT IS AN ELEMENT VS ROOT


element is a part of the path until separator
root is not considered part of the path


WHAT IF YOU CALL GETNAME WITH WRONG INDEX


/land/hippo/harry.happy = 3 elements
var p = Path.of("/");
System.out.print(p.getNameCount()); // 0
System.out.print(p.getName(0));     //IllegalArgumentException


HOW TO SELECT PORTIONS OF A PATH


public Path subpath(int beginIndex, int endIndex)
beginIndex = inclusive
endIndex   = exclusive


SUBPATH DIFFERENCE WITH GETNAME


getName() returns 1 element
subpath may return many elements


SAME THINGS GETNAME AND SUBPATH


also does not include root "/"
also exception on invalid indices


WHAT EXCEPTION DOES SUBPATH THROW


IllegalArgumentException


EXAMPLE OF INDICES WITH SUBPATH GOOD AND BAD


var p = Paths.get("/mammal/omnivore/raccoon.image");
mammal=0 omnivore=1 raccoon.image=2
subpath 0 to 3 is fine, since end is exclusive
subpath 0 to 4 is wrong -> IllegalArgumentException
subpath 1 to 1 also wrong since no element is selected


HOW TO ACCESS PARTICULAR PATH ELEMENTS


1 public Path getFileName() 

// element of current/LAST file/directory

2 public Path getParent()   

// full path of containing directory
// null on top of rel path

3 public Path getRoot()	    

// root element of file system
// null if rel path


EXAMPLE OF PRINTING RELATIVE PATH ELEMENTS


printPathInformation(Path.of("./armadillo/../shells.txt"));
path.getFileName() = shells.txt
path.getRoot() = null since relative path
get parent for each element with getParent()
	./armadillo/..
	./armadillo
	.
Most of the methods in this part of the chapter will treat path 
symbols as part of the path.


WHICH METHOD CLEANS UP RELATIVE PATHS


public boolean isAbsolute() 	// what is absolute depends on file system
public Path toAbsolutePath() 	// converts relative to absolute by 	
					joining it to the current working directory


EXAMPLE


var path2 = Paths.get("birds/condor.txt");
Path2 is Absolute? false
Absolute Path2 /home/work/birds/condor.txt
if current working dir is /home/work


WHAT IF TOABSOLUTEPATH() IS CALLED ON ABSOLUTE PATH


return the path


HOW TO CONCATENATE PATHS


public Path resolve(Path other)
public Path resolve(String other)


DIFFERENCE BETWEEN THESE 2


overloaded resolve(string) creates a Path for you


HOW DOES RESOLVE WORK


resolve = concatenation
the object on which resolve is called becomes the base Path and the 
argument is appended onto the Path


HOW DO RELATIVE AND ABSOLUTE ARGUMENTS WORK WITH RESOLVE


if input is relative path it is appended
if input is absolute path than that is the new path
no appending of absolute paths


HOW TO DERIVE A RELATIVE PATH FROM PATH1 TO PATH2


with public Path relativize()

path1.relativize(path2) 

// means how to get from 1 to 2 using rel path
// the file itself is a level as well		


EXAMPLE


var path1 = Path.of("fish.txt");
var path2 = Path.of("friendly/birds.txt");
System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));
../friendly/birds.txt //go up 1 level from fish and then to birds
../../fish.txt 	  	  //from birds go up 2 levels and then to fish

Path path3 = Paths.get("E:\\habitat");
Path path4 = Paths.get("E:\\sanctuary\\raven");
System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));

..\sanctuary\raven
..\..\habitat

what if E: drive doesnt exist?

no problem! filesystem is not accessed to determine paths


HOW DOES RELATIVIZE WORK WITH RELATIVE AND ABSOLUTE PATHS


both are relative then relativize assumes same current working dir
both are absolute then relativize calculates relative path regardless 
of current working dir


WHEN DO YOU GET AN EXCEPTION WITH RELATIVIZE


when you mix relative and absolute paths 
IllegalArgumentException


WHEN DO YOU ALSO GET AN EXCEPTION WITH RELATIVIZE ON WINDOWS


if both paths are absolute but not on the same root dir or drive
IllegalArgumentException


HOW CAN YOU CLEAN UP PATH SYMBOLS + EXAMPLES


public Path normalize()
var p1 = Path.of("./armadillo/../shells.txt");
System.out.println(p1.normalize()); // shells.txt
var p2 = Path.of("/cats/../panther/food");
System.out.println(p2.normalize()); // /panther/food
var p3 = Path.of("../../fish.txt");
System.out.println(p3.normalize()); // ../../fish.txt


WHY DIDNT THE LAST ONE DO ANYTHING


only symbols are removed if possible, last one is as short as it can 
get

Path path3 = Paths.get("E:\\data");
Path path4 = Paths.get("E:\\user\\home");
Path relativePath = path3.relativize(path4);
System.out.println(path3.resolve(relativePath));

relativePath = ..\user\home
E:\data + ..\user\home = E:\data\..\user\home

what does this last path mean?

start in E:\data
then go up 1 folder
then go into user\home

so the folder is actually just

E:\user\home !

so normalize this shit to get E:\user\home


HOW TO COMPARE EQUIVALENT PATHS


var p1 = Paths.get("/pony/../weather.txt");
var p2 = Paths.get("/weather.txt");
path1.normalize().equals(path2.normalize()) // true
This is the primary function of the normalize() method, to allow us 
to better compare different paths.


HOW TO RETRIEVE THE FILE SYSTEM PATH + DIFFERENCES & SIMILARITIES


public Path toRealPath(LinkOption... options) throws IOException
toRealPath = normalize + toAbsolutePath but with LinkOption and 
throws exception
like normalize it removes redundant path symbols
like toAbsolutePath it will join the rel path and the working dir
unlike these two methods it will throw an exception if path not exists
also it will follow symbolic links with optional varargs to ignore 


EXAMPLE


symbolic link from /zebra to /horse
current working directory of /horse/schedule
System.out.println(Paths.get("/zebra/food.txt").toRealPath());
System.out.println(Paths.get(".././food.txt").toRealPath());
// /horse/food.txt


HOW TO GET CURRENT WORKING DIR WITH TOREALPATH()


Path realPath = Path.of(".").toRealPath();


REVIEW ALL PATH METHODS


Path of(String, String...)
URI toURI(path)
File toFile(path)
String toString(path)
int getNameCount(path)
Path getName(int)
Path subpath(int, int)
Path getFileName()
Path getParent()
Path getRoot()
boolean isAbsolute()
Path toAbsolutePath()
Path relativize(path)
Path resolve(Path)
Path normalize()
Path toRealPath(LinkOption...) throws IOException


ARE THESE METHODS INSTANCE OR STATIC + WHICH ONES THROW EXCEPTION


they are all instance methods callable on Path instances
only toRealPath() throws an exception


HOW CAN YOU OPERATE ON FILES AND DIRECTORIES


With the NIO.2 Files class, similar to java.io.File but clearer


DO THE METHODS OF FILES THROW EXCEPTIONS OR NOT


do mostly throw exception because you want to operate on something


ARE ALL THE FILES METHODS STATIC OR NOT


all static methods callable with Files.methodeName(path)


HOW TO CHECK IF A FILE OR DIR IS REAL + EXAMPLES


public static boolean exists(Path path, LinkOption... options)
var b1 = Files.exists(Paths.get("/ostrich/feathers.png")); //file
System.out.println("Path " + (b1 ? "Exists" : "Missing"));
var b2 = Files.exists(Paths.get("/ostrich"));              //dir
System.out.println("Path " + (b2 ? "Exists" : "Missing"));


DO YOU REALLY KNOW IF IT IS A FILE OR DIRECTORY


no, because a dir can also have extension
unless exam tells you its a file or dir dont assume either


WHY DOES EXISTS() NOT THROW AN EXCEPTION


does not throw exception because it needs to return false instead


HOW TO CHECK IF PATH INSTANCES REFER TO SAME FILE


public static boolean isSameFile(Path path1, Path path2) throws 	
												IOException
follows symbolic links
resolves path symbols


DOES THIS METHOD POINT TO FILES ALONE


no despite name it can be used for both files and dirs


WHEN WILL THIS METHOD THROW EXCEPTION AND WHEN WONT IT


it will throw exception when a path does not exist UNLESS
the paths are equals(): then it will return true and not check if the 
paths exist


EXAMPLE


animals
-cobra <-
-monkey
--tail.gif
--ears.png
-wolf
--ears.png
-snake ->
symbolic link from /animals/snake to /animals/cobra

System.out.println(Files.isSameFile(   
	Path.of("/animals/cobra"),   
	Path.of("/animals/snake")));			//true
System.out.println(Files.isSameFile(   
	Path.of("/animals/monkey/ears.png"),   
	Path.of("/animals/wolf/ears.png")));	//false


HOW TO CREATE DIRECTORIES


public static Path createDirectory(Path dir,   
	FileAttribute<?>... attrs) throws IOException
public static Path createDirectories(Path dir,   
	FileAttribute<?>... attrs) throws IOException


WHEN WILL CREATEDIRECTORY THROW AN EXCEPTION


1 if dir already exists
2 if paths leading up to dir dont exist


HOW DOES CREATEDIRECTORIES WORK


create dir and all non-existant parent directories
if all dirs already exist it will do nothing
so it is: check if exist and create if not 


HOW TO COPY STUFF


public static Path copy(Path source, Path target, CopyOptions... 	
							options) throws IOException
copies files or dirs using path objects with get()


DOES COPY() USE SHALLOW OR DEEP COPY FOR DIRS


shallow meaning files and dirs in the dir are not copied
deep copies entire tree


WHAT IF THE TARGET OF COPY() ALREADY EXISTS


exception is thrown
override using StandardCopyOption.REPLACE_EXISTING


HOW TO COPY WITH I/O STREAMS


public static long copy(InputStream in, Path target, CopyOptions... 
							options) throws IOException
public static long copy(Path source, OutputStream out) throws IOException


HOW TO PROPERLY COPY WITH I/O STREAMS + EXAMPLE


use try-with-resources ofcourse!
try (var is = new FileInputStream("source-data.txt")) {
   // Write stream data to a file
   Files.copy(is, Paths.get("/mammals/wolf.txt"));
}

Files.copy(Paths.get("/fish/clown.xsl"), System.out);


WHAT TO BE MINDFUL OF WHEN COPYING FILE INTO A DIR


copy() operates on both files and dirs so if you copy a file into a 
dir this way:
copy("zoo.txt","/enclosure");
and both exist, you get an exception!
why? because copy() wants to create /enclosure but that already exists


HOW TO FIX THE PREVIOUS ERROR


copy("zoo.txt","/enclosure/zoo.txt");


HOW CAN YOU ALSO DEFINE DIRECTORY


with resolve
var directory = Paths.get("/enclosure").resolve(file.getFileName());


HOW TO MOVE AND/OR RENAME PATHS


public static Path move(Path source, Path target, CopyOptions... 	
						options) throws IOException


EXAMPLE


Files.move(Path.of("c:\\zoo"), 
		   Path.of("c:\\zoo-new"));
// renames the zoo dir to zoo-new and keeping all the content
Files.move(Path.of("c:\\user\\addresses.txt"),   
		   Path.of("c:\\zoo-new\\addresses2.txt"));
// moves addresses to new dir and renames it


WHEN WILL MOVE THROW AN EXCEPTION


if the target already exists
override with StandardCopyOptions.REPLACE_EXISTING


WHAT HAPPENS IF YOU MIX FILE AND DIR WITH MOVE


if source is file and target is dir it will create a new file with 
the name of the dir


HOW TO PREVENT FILE SYSTEM SEEING INCOMPLETE FILE


use option StandardCopyOption.ATOMIC_MOVE


WHAT IF FILE SYSTEM DOES NOT SUPPORT ATOMIC MOVE


AtomicMoveNotSupportedException


WILL ATOMIC_MOVE WORK ON COPY() OR MOVE()


move(), if used on copy() you will likely get an exception


HOW TO DELETE A FILE OR DIRECTORY


public static void 	  delete(Path path) throws IOException
public static boolean deleteIfExists(Path path) throws IOException


WHEN WILL THESE METHODS THROW AN EXCEPTION


the dir must be empty otherwise exception


WHAT IF YOU DELETE A PATH THAT IS A SYMBOLIC LINK


the symbolic link will be deleted and not the actual target


DIFFERENCE BETWEEN THESE METHODS


delete() throws exception if path does not exist
deleteIfExists() returns true if succesful or false just like 
createDirectories()


EXAMPLES


Files.delete(Paths.get("/vulture/feathers.txt")); //delete feathers
Files.deleteIfExists(Paths.get("/pigeon")); //tries to delete pigeon
									 		  if empty


HOW TO USE NIO.2 FILES WITH I/O STREAMS


public static BufferedReader newBufferedReader(
			Path path, Charset) throws IOException
public static BufferedWriter newBufferedWriter(
			Path path, OpenOption... options) throws IOException


EXAMPLE


Path path = Path.of("/animals/bear.txt");
try (BufferedWriter writer = 
		 Files.newBufferedWriter(path, Charset.forName("UTF-16"))) {
   writer.write("Hello");      
   writer.newLine();
 }
}


HOW TO GET SYSTEM DEFAULT CHARSET


Charset.defaultCharset()


WHAT HAPPENS IF BEAR.TXT DOES NOT EXIST


it creates the file


WHAT HAPPENS IF BEAR.TXT DOES EXIST


it overwrites the file


HOW TO READ ENTIRE FILE INTO LIST


public static List<String> readAllLines(Path path) throws IOException


WHY ARE THERE NO LOW LEVEL STREAMS USED


because NIO.2 wants you to always use Buffered streams


ALL FILES METHOD RECAP + WHICH ONE THROW AN EXCEPTION


boolean 				exists(path, linkoption)
boolean 				isSameFile(path1, path2)
Path 					createDirectory(path, fileaattributes)
Path 					createDirectories(path, fileattributes)
Path 					copy(path, path, copyoption)
long 					copy(inputstream, path, copyoption)
long 					copy(path, outputstream)
Path 					move(path, path, copyoption)
void 					delete(path)
boolean 				deleteIfExists(path)
BufferedReader 	newBufferedReader(path)
BufferedWriter 	newBufferedWriter(path, openoption)
List<String> 		readAllLines(path)

all throw IOException except for exists()


WHAT ARE FILE ATTRIBUTES


metadata about files and directories not being file content
such as size, visibility etc


HOW TO DETERMINE TYPE OF A PATH


public static boolean isDirectory(Path path, LinkOption... options)
public static boolean isSymbolicLink(Path path)
public static boolean isRegularFile(Path path, LinkOption... options)


WHERE ARE THESE METHODS LOCATED


in Files class


WHY DONT THEY THROW AN EXCEPTION LIKE THE REST


because they need to be able to return false 


WHEN WILL THEY RETURN TRUE OR FALSE


for isRegularFile and isDirectory they will return true if

the thing is file/dir or is a symbolic link

if its a link, it will 

perform the check on the actual target of the link


HOW DOES ISYMBOLICLINK WORK


returns true if its a symbolic link whether the file exists or not


HOW DOES ISREGULARFILE WORK WITH SYMBOLIC LINK


regular files are not link, resource, directory or non-regular file
but, if the symbolic link points to an actual file with content it 
will return true


HOW TO CHECK FILE ACCESSIBILITY


public static boolean isHidden(Path path) throws IOException
public static boolean isReadable(Path path)
public static boolean isExecutable(Path path)
public static boolean size(Path path)


IMPORTANT EXAM THING TO REALIZE FOR THE ABOVE 7 METHODS


dont assume anything, answer question in the form that "it depends"
it depends on if its an actual file, whether its hidden, is it a dir
dont jump to conclusions and see if there is a "if this and that" answer


HOW CAN YOU MANAGE OWNERSHIP


with Files.getOwner(Path) and Files.setOwner(Path, UserPrincipal)


WHAT DO THESE 2 METHODS RETURN


UserPrincipal


DO THEY THROW AN EXCEPTION


yes IOException


HOW TO SET A USER - FIRST STEP


get a FileSystem object with either

FileSystems.getDefault()

or via

path.getFileSystem()


WHAT METHOD TO FIND USERS


getUserPrincipalLookupService().lookupPrincipalByName


EXAMPLE


try {
	// Read owner of file
	Path path = Paths.get("/chicken/feathers.txt");
	System.out.println(Files.getOwner(path).getName());
	// Change owner of file
	UserPrincipal owner = path.getFileSystem()
		.getUserPrincipalLookupService()
		.lookupPrincipalByName("jane");
	Files.setOwner(path, owner);
	// Output the updated owner information
	System.out.println(Files.getOwner(path).getName());
} catch (IOException e) { // Handle file I/O exception... }

random owner
jane


HOW TO READ SIZE


public static long size(Path path) throws IOException


WHAT WILL THE SIZE RETURN ON FILE OR DIRECTORY


file: it will return conceptual size of the data, not actual storage
dir: it will be undefined, results depend on file system
for dir you need to walk the tree


HOW TO READ LAST TIME MODIFIED + WHY IS THIS USEFUL


public static FileTime getLastModifiedTime(Path path, LinkOption...
 options) throws IOException
useful to know when you need to open a file again
better than reloading entire content to see for changes


WHAT IS FILETIME AND HOW TO USE


FileTime represents a timestamp and has a toMillis() function to give
epoch time


WHAT IS EPOCH TIME


milliseconds since 12am UTC January 1 1970


System.out.println(Files.getLastModifiedTime(path).toMillis());
Files.setLastModifiedTime(path, FileTime.fromMillis(
								  System.currentTimeMillis()));


WHAT IS A BETTER WAY TO GET ALL THE ATTRIBUTES


NIO.2 uses views to get all attributes file system spicific
this is more efficient than asking for all attribs seperately


WHAT IS A VIEW


a group of related attributes for a particular file system


WHAT IS THE NIO.2 READ-ONLY ATTRIBUTES METHOD + EXAMPLE


// in Files.class
readAttributes(path,class<>,options) throws IOException

var path = Paths.get("/turtles/sea.txt");
BasicFileAttributes data = Files.readAttributes(
	path, 
	BasicFileAttributes.class);


WHAT DOES THE BASICFILEATTRIBUTES CLASS HOLD


same methods as the Files methods for attributes! you just get all of 
the attributes at once instead of one at a time
but this is readonly, if you want to update the attibs use next method


WHAT DOES THE ISOTHER() METHOD REPRESENT


for stuff that is not a isDirectory(), isRegularFile() or symboliclink


WHAT DOES FILEKEY() REPRESENT


the unique identifier of the file on the filesystem 

returns null if not supported


WHAT IS THE NIO.2 UPDATABLE VIEW ATTRIBUTES METHOD + EXAMPLE


// in Files.class
getFileAttributeView(Path,Class<V>,LinkOption...)


HOW TO SET TIMES ON BASICFILEATTRIBUTEVIEW  


// BasicFileAttributeView instance method
public void setTimes(FileTime lastModifiedTime,   
				 	 		FileTime lastAccessTime, 
					 		FileTime createTime)
This method allows null for any date/time value that you do not want 
to modify.


WHAT DOES CLASS<A> TYPE REFER TO


You need to use the right class with the right method:
readAttributes needs a class that extends BasicFileAttributes
getFileAttributeView needs a class that extends FileAttributeView
interface BasicFileAttributes -> BasicFileAttributes.class
interface FileAttributeView -> BasicFileAttributeView.class

BasicFileAttributes data = view.readAttributes();


HOW TO LIST DIRECTORY CONTENTS WITH A STREAM + BENEFIT VS FILE


public static Stream<Path> list(Path dir) throws IOException
The benefit is that a Stream uses lazy evaluation so each path 
element is loaded as needed instead of entire dir at once like 
java.io.File File[] listFiles() does.


HOW TO PERFORM A DEEP COPY OF A DIR WITH STREAM


public void copyPath(Path source, Path target) {   
	try {      
		Files.copy(source, target);      
		if(Files.isDirectory(source))         
			try (Stream<Path> s = Files.list(source)) {
				s.forEach(p -> copyPath(p, 
							target.resolve(.getFileName())));
		     }   
     } catch(IOException e) {      
     	// Handle exception   
     }
}
TRY-WITH-RESOURCES!!! CHECK IF THE EXAM CLOSES THE RESOURCE OR NOT 
USING TRY-WITH-RESOURCES


WHAT HAPPENS WITH A SYMBOLIC LINK


JVM does not follow symbolic links this way


HOW TO COMPLETELY GO THROUGH ALL THE DIRS


even deep copy is not enough, you need to:

walk or traverse the directory tree



WHICH SEARCH STRATEGIES ARE THERE


1 depth-first search: from root to arbitrary leaf up and down
2 breadth-first search: from root all elements in level then down


WHAT IS SEARCH DEPTH


a limit on how many levels or hops from the root the search can go


WHICH STRATEGY DOES NIO.2 STREAM API METHODS USE


depth-first with a depth limit that can be optionally changed


HOW TO WALK THE DIRECTORY


public static Stream<Path> walk(Path start, 
	FileVisitOptions... options) throws IOException
public static Stream<Path> walk(Path start, int maxDepth, 
	FileVisitOptions... options) throws IOException


WHAT IS THE DEFAULT MAXIMUM DEPTH


Integer.MAX_VALUE


HOW TO GET TOTAL SIZE OF ALL FILES IN DIR


public long getPathSize(Path source) throws IOException


HOW DOES OPTIONAL DEPTH PARAM WORK


try (var s = Files.walk(source, 5)) {
0 = current path so you need at least 1 to get nonzero result


DOES WALK() FOLLOW SYMBOLIC LINKS


Most methods do by default, but walk() does not!
You need to override it:
try (var s = Files.walk(source, FileVisitOption.FOLLOW_LINKS)) {


HOW DOES A CYCLE WORK


birds
-robin <-
--pictures
---nest.png
---wings.gif
--allBirds -> symbolic link to /birds/robin

depth level 0 is /birds/robin because its the start
depth level 1 is /birds/robin/pictures
depth level 1 is /birds/robin/allBirds -> /birds
depth level 2 is /birds/robin/pictures/nest.png
depth level 2 is /birds/robin/pictures/wings.gif
depth level 2 is /birds/robin/allBirds/birds
this is still no cycle because we havent visited /birds before
depth level 3 is /birds/robin/allBirds/birds/robin -> /birds/robin
NOW its a cycle because we have visited /birds/robin before


WHAT HAPPENS IF YOU USE FOLLOW_LINKS AND ENCOUNTER A CYCLE


the walk() method will track all of the paths it has visited, 
throwing a FileSystemLoopException if a path is visited twice


HOW TO SEARCH FOR A DIRECTORY


public static Stream<path> find(
		Path start,
		int maxDepth,  //required!
		BiPredicate<Path,BasicFileAttributes> matcher,
		FileVisitOption... options) throws IOException
Path path = Paths.get("/bigcats");
long minSize = 1_000;
try (var s = Files.find(
		path, 
		10,
		(p, a) -> a.isRegularFile() &&
				p.toString().endsWith(".java") && 
				a.size() > minSize)) {
				   s.forEach(System.out::println);
}


HOW TO READ ALL LINES BETTER THAN FILES.READALLALINES()


with Stream API

public static Stream<String> lines(Path path) throws IOException

benefit is contents of files are read lazily so only a little memory 
is used runtime

Files.readAllLines(Paths.get("bis.txt")).forEach(System.out::println);
Files.lines       (Paths.get("bis.txt")).forEach(System.out::println);

//same thing but method 1 reads entire file into memory first and 
then does something and method 2 reads lazily a small portion


BAD MIX EXAMPLE


Why doesnt this compile?
Files.readAllLines(Paths.get("birds.txt"))      
	.filter(s -> s.length()> 2)      
	.forEach(System.out::println);
//readAllLines returns a List and that has no filter() method




BIG COMPARISON FILE FILES TABLE

file is instance of java.io.File
path/otherPath are instances of NIO.2 Path interface
NIO.2 also can follow symbolic links, setting file system specific 
attributes etc

Legacy I/O File method 	NIO.2 method
file.delete()					Files.delete(path)
file.exists()					Files.exists(path)
file.getAbsolutePath()		path.toAbsolutePath()
file.getName()					path.getFileName()
file.getParent()				path.getParent()
file.isDirectory()			Files.isDirectory(path)
file.isFile()					Files.isRegularFile(path)
file.lastModified()			Files.getLastModifiedTime(path)
file.length()					Files.size(path)
file.listFiles()				Files.list(path)
file.mkdir()					Files.createDirectory(path)
file.mkdirs()					Files.createDirectories(path)
file.renameTo(otherFile)	Files.move(path,otherPath)



CHAPTER 9 QUESTIONS


> DONT PASS A STRING TO A METHOD THAT NEEDS A PATH OBJECT!!!!
relativize("/folder") = WRONG 
relativize(Paths.get("/folder")) = correct

>
path = /kang = link and points to /mammal/kangaroo
isDirectory(path) = true
isSymbolicLink(path) = true
createDirectory(path.resolve("joey")
creates /mammal/kangaroo/joey
accessible by /kang/joey!


>
The REPLACE_EXISTING flag was not provided, so if the target exists, it 

will throw an exception at runtime. 

Next, the NOFOLLOW_LINKS option means that if the source is a symbolic 
link, 

the link itself and not the target will be copied at runtime. 

The option ATOMIC_MOVE means that any process monitoring the file 
system 

will not see an incomplete file during the move.

Moving always preserves the metadata even if the COPY_ATTRIBUTES flag 
is not set.

>
17.Assuming the current directory is /animals/cute, which are possible
results of executing the following code? (Choose all that apply.)

Files.walk(Paths.get("..").toRealPath().getParent())  // u1   
	.map(p -> p.toAbsolutePath().toString()) // u2   
	.filter(s -> s.endsWith(".java")) // u3   
	.collect(Collectors.toList())   
	.forEach(System.out::println);

Nothing wrong with the code: walk() resolves to /

toRealPath does toAbsolutePath + normalize
/animals/cute + /.. + normalize = /animals getParent = /

so the code says: print everything from the filesystem

you may encounter an exception if a file is not allowed to be read


>
current directory is /seals/harp/food
final Path path1 = Paths.get(".").normalize();
final Path path2 = Paths.get(".").toRealPath();

difference?

path1 = .
path2 = /seals/harp/food

path1 = . so what does getNameCount return?

1 !! because its only current dir





---------------  [[[CHAPTER 10]]] --------------------p.506/558









JDBC stands for Java Database Connectivity.
Java Database Connectivity Language (JDBC): Accesses data as rows and 
columns. JDBC is the API covered in this chapter.
A relational db is accessed through Structured Query Language(SQL).


WHAT ARE THE FOUR TYPES OF STATEMENTS IN SQL


Create
Read
Update
Delete


WHAT ARE THE SQL KEYWORDS ASSOCIATED WITH THE TYPES


Insert
Select
Update
Delete


HOW IS JDBC DISTRIBUTED


Five key interfaces in a JAR that is shipped as driver with a db


WHAT ARE THE FIVE KEY INTERFACES YOU NEED TO KNOW


1 Driver
2 Connection
3 Statement
4 ResultSet


WHAT DO THESE KEY INTERFACES DO ON A HIGH LEVEL


1 Driver: 	  Knows how to get a connection to the database
2 Connection: Knows how to communicate with the database
3 Statement:  Knows how to run the SQL
4 ResultSet:  Knows what was returned by a SELECT query


IN WHAT PACKAGE ARE THESE INTERFACES


java.sql


HOW TO BUILD A JDBC URL


three parts
    1         2         3 
protocol:subprotocol:subname
protocol 		= always jdbc
subprotocol 	= name of the database postgres mysql etc
subname 		= database specific connection details
//examples
jdbc:postgres://localhost:5250/zoo
jdbc:derby:zoo
jdbc:postgresql://localhost/zoo
jdbc:oracle:thin:@123.123.123.123:1521:zoo
jdbc:mysql://localhost:3306
jdbc:mysql://localhost:3306/zoo?profileSQL=true


WHAT ARE EXAM TRICKS FOR SUBNAME


it has to specify the location of the database
so local is wrong, needs to be localhost
//126354 is wrong because what is this?
IP or localhost


HOW TO CONNECT TO A DATABASE


use the factory pattern of DriverManager, not the constructor


WHY DO YOU USE FACTORY PATTERNS INSTEAD OF CONSTRUCTOR


so you dont have to worry about the implementing classes of the driver


DriverManager.getConnection(jdbcUrl)
DriverManager.getConnection(jdbcUrl,username,password)


WHEN CAN YOU EXPECT A SQLEXCEPTION


when you use 
Connection conn = DriverManager.getConnection("jdbc:derby:zoo"); 
without having the driver on the classpath
message is not important for exam


WHICH CLASS CAN YOU EXPECT WITH PREVIOUS METHOD


Probably not Connection but a vendor specific impl class XxxConnection
Unless the exam specifies a command line, you can assume that the 
correct JDBC driver JAR is in the classpath. The exam creators 
explicitly ask about the driver JAR if they want you to think about 
it.


HOW TO OBTAIN A STATEMENT - TWO WAYS


Statement stmt = conn.createStatement();
Statement stmt = conn.createStatement(   
								 ResultSet.TYPE_FORWARD_ONLY,
								 ResultSet.CONCUR_READ_ONLY);


SECOND METHOD - WHICH PARAMETER COMES FIRST AND WHY


the resultset type


WHICH TYPES ARE THERE - 3


1 forward_only
2 scroll_insensitive
3 scroll_sensitive


WHAT IS FORWARD_ONLY


go through data once in order in which it was retrieved


WHAT IS SCROLL_INSENSITIVE AND SENSITIVE


go through data in any order. forward and backward and specific spot


DIFFERENCE BETWEEN THESE TWO


insensitive is static view of the result as it was and doesnt change
sensitive is the same but changes if data in table changes

sensitive is BS and you dont need to know it other than it exists


WHAT IS THE SECOND TYPE FOR PARAMETER


resultset concurrency mode


WHAT DOES THIS MEAN


wether or not you can update the db through the resultset


WHAT OPTIONS ARE THERE


CONCUR_READ_ONLY and CONCUR_UPDATABLE


CONCUR_UPDATABLE AND TYPE_SCROLL_SENSITIVE ARE BS


they are rarely supported and get downgraded but you need to recognise 
them


WHICH TWO METHODS CAN YOU USE WITH STATEMENT


executeUpdate()
executeQuery()


WHEN DO YOU USE ONE OR THE OTHER


executeUpdate() for insert, update, delete queries


executeQuery() for select queries


HOW TO CREATE A STATEMENT


Statement stmt = conn.createStatement();

NOTICE NO PARAMETER!


HOW TO EXECUTE A STATEMENT WITH INSERT, DELETE, UDPATE


int result = stmt.executeUpdate(SQLqueryStringHere);
		"insert into species values(10, 'Deer', 3)"
		"update species set name = '' where name = 'None'"
		"delete from species where id = 10"


WHY INT RESULT RETURN


because the return is the number of rows affected


HOW TO EXECUTE A STATEMENT WITH SELECT


ResultSet rs =  stmt.executeQuery("select * from species");


WHY RESULTSET RETURN NOW


because you get the actual result from the query this time

boolean isResultSet = stmt.execute(sql);
if (isResultSet) {   
	ResultSet rs = stmt.getResultSet();   
	System.out.println("ran a query");
} else {   
	int result = stmt.getUpdateCount();   
	System.out.println("ran an update");
}


WHAT HAPPENS IF YOU USE THE WRONG METHOD FOR STATEMENT


Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
Statement stmt = conn.createStatement();
int result = stmt.executeUpdate("select * from animal");

you get SQLException: A result was returned when none was expected.
Or No results were returned by the query.


WHY NOT COMPILER


because compiler cant read your string


RECAP: SQL BY EXECUTE METHODS - WHICH OPERATIONS ARE ALLOWED


stmt.execute()

insert,delete,update,select

stmt.executeQuery()

select

stmt.executeUpdate()

insert,delete,update


RECAP: SQL BY EXECUTE METHODS - RETURN TYPES


stmt.execute()

boolean true for select and false for insert,delete,update

stmt.executeQuery()

Resultset all rows and columns affected

stmt.executeUpdate()

int number of rows affected


HOW TO GET DATA FROM RESULTSET


20:   Map<Integer, String> idToNameMap = new HashMap<>();
21:   ResultSet rs =  stmt.executeQuery("select id, name from species");
22:   while(rs.next()) {
23:      int id = rs.getInt("id");
24:      String name = rs.getString("name");
25:      idToNameMap.put(id, name);
26:   }
27:   System.out.println(idToNameMap); // {1=African Elephant, 2=Zebra}


HOW DOES NEXT() WORK WITH RESULTSET AND WHAT IS A CURSOR


rs.next() -> each loop is a row
the cursor starts at the top and goes down after each row
start -> 		headers
next() = true 	row 1
next() = true 	row 2
next() = false 


HOW TO GET DATA FROM A ROW IN NEXT()


getInt("id")
getString("name")
   OR
getInt(1)
getString(2)


HOW DOES RESULTSET COUNT


starting from 1 and not 0


DO YOU NEED TO CHECK IF NEXT() IS TRUE BEFORE GETTING


yes because if there are no rows in the resultset you get SQLException


WHY SQLEXCEPTION IF YOU DO NOT CALL NEXT() BEFORE GET


because cursor is still pointing to the header row and not a data row
so getInt(1) returns an error
use next() to point at the first data row so you can get() something


THINGS TO REMEMBER WITH RESULTSET


1 always use if or while before get and do something with result
2 column and row indexes begin with 1


WHEN DO YOU GET A SQLEXCEPTION WITH RESULTSETS


1 calling get with a column name that doesn exist
2 calling get on index 0 or one that doesn exist
3 calling get without calling next first
4 calling next but not checking the result and calling get anyway

ResultSet rs =  stmt.executeQuery(
	"select * from animal where name= 'Not in table'");
rs.next();
rs.getInt(1);

ResultSet rs =  stmt.executeQuery("select count(*) from animal");
rs.getInt(1);

ResultSet rs =  stmt.executeQuery("select count(*) from animal");
rs.next();
rs.getInt(0);

ResultSet rs =  stmt.executeQuery("select id from animal");
rs.next();
rs.getInt("badColumn");


HOW TO GET DATA FROM A COLUMN


getInt 				int 
getLong 				long
getDouble 			double
getBoolean 			boolean
getString 			String
getObject 			Object (for all wrapper classes)
getDate 				java.sql.Date
getTime 				java.sql.Time
getTimeStamp 		java.sql.TimeStamp


date/time of birth of one of our animals as 2001–05–06 02:15

ResultSet rs = stmt.executeQuery(
		"select date_born from animal where name = 'Elsa'");
if (rs.next()) {   
	java.sql.Date sqlDate = rs.getDate(1);   
	LocalDate localDate = sqlDate.toLocalDate();   
	System.out.println(localDate);

	java.sql.Time sqlTime = rs.getTime(1);   
	LocalTime localTime = sqlTime.toLocalTime();   
	System.out.println(localTime);

	java.sql.Timestamp sqlTimeStamp = rs.getTimestamp(1);   
	LocalDateTime localDateTime = sqlTimeStamp.toLocalDateTime();   
	System.out.println(localDateTime);
}


WHAT DOES GETDATE() RETURN


the year month and day


WHAT DOES OBJECT RETURN


16:   ResultSet rs =  stmt.executeQuery("select id, name from species");
17:   while(rs.next()) {
18:      Object idField = rs.getObject("id");
19:      Object nameField = rs.getObject("name");
20:      if (idField instanceof Integer) {
21:        int id = (Integer) idField;
22:        System.out.println(id);
23:      }
24:      if (nameField instanceof String) {
25:         String name = (String) nameField;
26:         System.out.println(name);
27:     }
28:  }


WHAT DOES SCROLLING A RESULTSET MEAN


point the cursor at any row


SCROLLING METHODS


boolean next()

point to next row if available

boolean previous()

point to previous row if available

boolean first()
boolean last()

beginning or end of a resultset

void beforeFirst()
void afterLast()

boolean absolute(int)

go to row of int
true if available, false if not
1,2,3 etc go to that row
0 = go to row before first row, so header row = 0

boolean absolute(negative int)

what happens?

count from end of rows

EXAMPLE

HEADERROW
1
2
3
4
5

36:   Statement stmt = conn.createStatement(
37:      ResultSet.TYPE_SCROLL_INSENSITIVE,
38:      ResultSet.CONCUR_READ_ONLY);
39:   ResultSet rs = stmt.executeQuery("select id fromanimalorderby id");
40:   System.out.println(rs.absolute(2));        // true
41:   System.out.println(rs.getString("id"));    // 2
42:   System.out.println(rs.absolute(0));        // false
43:   System.out.println(rs.absolute(5));        // true
44:   System.out.println(rs.getString("id"));    // 5
45:   System.out.println(rs.absolute(-2));       // true
46:   System.out.println(rs.getString("id"));    // 4

-2 is second to last row

boolean relative(int)

just go up (positive) or down (begative) int number of rows

51:   Statement stmt = conn.createStatement(
52:      ResultSet.TYPE_SCROLL_INSENSITIVE,
53:      ResultSet.CONCUR_READ_ONLY);
54:   ResultSet rs = stmt.executeQuery("select idfromanimalorderbyid");
55:   System.out.println(rs.next());          // true
56:   System.out.println(rs.getString("id")); // 1
57:   System.out.println(rs.relative(2));     // true
58:   System.out.println(rs.getString("id")); // 3
59:   System.out.println(rs.relative(-1));    // true
60:   System.out.println(rs.getString("id")); // 2
61:   System.out.println(rs.relative(4));     // false


IN WHAT ORDER MUST YOU CLOSE JDBC


1 ResultSet first
2 Statement
3 Connection


DO YOU ALWAYS NEED TO CLOSE ALL RESOURCES


No, closing Connection also closes the other 2
Closing Statement also closes ResultSet


HOW CAN YOU GET A RESOURCE LEAK EVEN WITH TR-W-RES


if you assign and use the resources before the try-w-res block
40: public void bad() throws SQLException { 
41:    var url = "jdbc:derby:zoo"; 
42:    var sql = "SELECT not_a_column FROM names"; 
43:    var conn = DriverManager.getConnection(url); 
44:    var ps = conn.prepareStatement(sql); 
45:    var rs = ps.executeQuery();   // what if exception here?
46: 
47:    try (conn; ps; rs) { 
48:       while (rs.next()) 
49:          System.out.println(rs.getString(1)); 
50:    } 
51: }


WHAT ELSE CLOSES A RESULTSET


running another sql statement on the same Prepared/CallableStatement


HOW MANY RESOURCES ARE BEGIN CLOSED HERE


14:   String url = jdbc:derby:zoo";
15:   try (Connection conn = DriverManager.getConnection(url);
16:        Statement stmt = conn.createStatement();
17:        ResultSet rs = stmt.executeQuery(
							"select count(*) from animal")) {
18:
19:     if (rs.next()) System.out.println(rs.getInt(1));
20:
21:     ResultSet rs2 = stmt.executeQuery("select count(*) from animal");
22:     int num = stmt.executeUpdate(
23:         "update animal set name = 'clear' where name = 'other'");
24:   }


1 resource on 17 to run a query
2 resource on 21 to run another query, closing rs
3 resource on 23 to run another query, closing rs2
4 after 24 the connection is closed


so 4 resources closed here


EXCEPTIONS


String url = " jdbc:derby:zoo";
try (Connection conn = DriverManager.getConnection(url ");     
Statement stmt = conn.createStatement();     
ResultSet rs = stmt.executeQuery("select not_a_column from animal")) {
	while (rs.next()) System.out.println(rs.getString(1));
} catch (SQLException e) {   
	System.out.println(e.getMessage());   
	System.out.println(e.getSQLState());   
	System.out.println(e.getErrorCode());
}


ERROR: column "not_a_column" does not exist    
	Position: 8  
42703  
0

returns a human-readable message
returns a code as to what went wrong
database-specific code


CHAPTER QUESTIONS

>
Driver, Connection, Statement, and ResultSet interfaces and
concrete class DriverManager are part of the JDK itself


>
required for jdbc url:
jdbc
vendor/productname
database name
The location, such as IP address and port, is optional.

>
since JDBC 4.0 driver needs to be located on classpath:

META-INF/service/java.sql.Driver

>
Class.forName() was used with old JDBC drivers to load the driver. 
It is not needed in JDBC 4.0. If it is called, it throws a 

ClassNotFoundException. 

By contrast, DriverManager.getConnection() throws a 

SQLException when the driver cannot be found. 

>
JDBC code throws a 

SQLException, which is a checked exception


>
A Statement automatically closes the open ResultSet when another SQL
statement is run. 

This means that rs is no longer open by the println, and a 

SQLException is thrown because the ResultSet is closed.

>
JDBC date and time methods:
getDate
getTime
getTimeStamp

>
Statement stmt = conn.createStatement();
rs.previous();

problem?

default stmt is NOT scrollable ...

>
absolute(0) moves the cursor to a location immediately 

before the results

>
ten rows:
ResultSet rs = stmt.executeQuery(sql)) {   
	System.out.println(rs.absolute(0));   		//1 before results
	System.out.println(rs.absolute(5));   		//line 5
	System.out.println(rs.previous());   		//line 4
	System.out.println(rs.relative(-2));    	//line 2
	System.out.println(rs.relative(-100));		//line???
}

line before results!!


ten rows:
ResultSet rs = stmt.executeQuery(sql));  
	System.out.println(rs.beforeFirst());   
	System.out.println(rs.absolute(5));   
	System.out.println(rs.previous());   
	System.out.println(rs.relative(-2));   
	System.out.println(rs.afterLast());
}

problem?

what do beforeFirst and afterLast return?

void

what cant you print with sout?

void ...... no compile!!!